open global

type ('a, 's, 'msg) t = 's -> ('a * 's, 'msg) exception`t

let unit a = fun s -> exception`unit (a, s)

let map f m =
  fun s -> exception`bind (m s) (fun (a, s') -> exception`unit (f a, s'))

let join mm = fun s -> exception`bind (mm s) (fun (m, s') -> m s')

let bind m f = join (map f m)

let app mf m = bind mf (fun f -> map f m)

let fail msg = fun _ -> exception`fail msg
let update f = fun s -> exception`unit ((), f s)
let modify f = fun s -> exception`unit (f s)
let read   f = fun s -> exception`unit (f s, s)

let of_option msg = function
  | Some a -> unit a
  | None   -> fail msg
end

let option msg m =
  let f o =
    match o with
      | Some a -> unit a
      | None   -> fail msg
    end in
  bind m f

module operators = struct
  let (>>=) = bind
  let (<$>) = map
  let (<*>) = app
end

open operators

let map2 f mx my = f <$> mx <*> my

let sequence ms =
  List`fold_right
    (fun m m' ->
      m  >>= (fun x  ->
      m' >>= (fun xs ->
      unit (x::xs)))
    ) ms (unit [])

let t_list t xs = sequence (t xs)

let map_list f = t_list (List`map f)

let rec foldr_list f l a =
  match l with
    | [] -> unit a
    | x::xs -> f x a >>= (fun a' -> foldr_list f xs a')
  end

let iter f l = foldr_list (fun a () -> f a) l ()

(*
let map_list f xs =
  List`fold_right (fun x -> map2 list`cons (f x)) xs (unit [])
*)