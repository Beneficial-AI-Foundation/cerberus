open global

module c = cabs
module a = ail

module effect = struct
  module st = symbol_table

  type id = symbol`t
  type id_set = symbol`set

  type ('a_e, 'a_s) env = <|
    symbol_set : id_set;
    symbol_table : (string, id) st`t;
    id_map : (id, a`declaration) map;
    globals : (id * (id, 'a_e) a`exp) list;
    fn_map : (id, (id list * (id, 'a_e, 'a_s) a`stmt)) map
  |>

  type ('a, 'a_e, 'a_s, 'msg) t = ('a, ('a_e, 'a_s) env, 'msg) state_exception`t

  let unit = state_exception`unit
  let map  = state_exception`map
  let join = state_exception`join
  let bind = state_exception`bind

  let fail = state_exception`fail

  let app  mf m = bind mf (fun f -> map f m)
  let papp mf x = bind mf (fun f -> unit (f x))

  let option = state_exception`option
  let of_option = state_exception`of_option
  let map_list = state_exception`map_list
  let foldr_list = state_exception`foldr_list
  let iter = state_exception`iter
  let t_list = state_exception`t_list

  let initial_state = <|
    symbol_set = symbol`emp;
    symbol_table = st`create_scope st`emp;
    id_map = Pmap`empty;
    globals = [];
    fn_map = Pmap`empty
  |>

  let update = state_exception`update

  let destroy_scope =
    let f env = <|env with symbol_table = st`destroy_scope env.symbol_table|> in
    update f

  let create_scope =
    let f env = <|env with symbol_table = st`create_scope env.symbol_table|> in
    update f

  let push_table t =
    let f env = <|env with symbol_table = st`push_table t env.symbol_table|> in
    update f

  let add_id id decl=
    let f env = <|env with id_map = Pmap`add id decl env.id_map|> in
    update f

  let add_fn id formals body=
    let f env = <|env with fn_map = Pmap`add id (formals, body) env.fn_map|> in
    update f

  let add_globals defns =
    let f env = <|env with globals = env.globals @ defns|> in
    update f

  let fresh_name name =
    let f env =
      let (symbol, symbol_set') = symbol`fresh_pretty name env.symbol_set in
      let env' =
      <|env with
        symbol_set = symbol_set';
        symbol_table = st`add name symbol env.symbol_table
      |> in
      (symbol, env') in
    state_exception`modify f

  let resolve name =
    let f env = st`find name env.symbol_table in
    state_exception`read f

  let return_scope =
    let f env = st`return_scope env.symbol_table in
    state_exception`read f

  let symbols =
    let f env = st`symbols env.symbol_table in
    state_exception`read f

  let to_program main =
    let f env = <|
      a`main = main;
      a`id_map = env.id_map;
      a`globals = env.globals;
      a`fn_map = env.fn_map
    |> in
    state_exception`read f

  module operators = struct
    let (>>=) = bind

    let (<$>) = map
    let (<*>) = app
    let (<@>) = papp
  end

  open operators

  let app2 mf mx my = mf <*> mx <*> my
  let app3 mf mx my mz = (app2 mf mx my) <*> mz
  let map2 f mx my = f <$> mx <*> my
  let map3 f mx my mz = (map2 f mx my) <*> mz
end

open effect`operators

let zero l = (c`CONSTANT (c`CONST_INT (0, None)), l)
let one  l = (c`CONSTANT (c`CONST_INT (1, None)), l)
let d_zero l = a`Exp l (a`CONSTANT (c`CONST_INT (0, None)))
let d_one  l = a`Exp l (a`CONSTANT (c`CONST_INT (1, None)))

let subst l name =
  let msg = "Violation of constraint 6.7#3 as described by footnote 91 \
             ``[A]n undeclared identifier is a violation of syntax`` in\n" in
  effect`option msg (effect`resolve name)

let desugar_unop = function
  | c`MINUS -> a`MINUS
  | c`PLUS -> a`PLUS
  | c`BNOT -> a`BNOT
  | c`POSTFIX_INCR -> a`POSTFIX_INCR
  | c`POSTFIX_DECR -> a`POSTFIX_DECR
  | c`ADDRESS -> a`ADDRESS
  | c`INDIRECTION -> a`INDIRECTION
end

let rec
| desugar_exp (e, l) =
  let f  = desugar_exp in
  let ft = desugar_type in
  a`Exp l <$> (match e with
    (* 6.5.2.1#2 Array subscripting, Semantics: "The definition of the
       subscripting operator [...] is that [[ E1[E2] ]] is identical to [[
       ( *((E1)+(E2))) ]]". *)
    | c`INDEX e1 e2 ->
        a`UNARY a`INDIRECTION <$> (
          a`Exp l <$> (
            a`BINARY (c`ARITHMETIC c`ADD) <$> f e1 <*> f e2
          )
        )
    (* 6.5.3#2 Unary operators, Semantic says: "The expression [[ ++E ]] is
       equivalent to [[ (E+=1) ]]". *)
    | c`UNARY c`PREFIX_INCR e ->
        a`ASSIGN (Some c`ADD) <$> f e <@> d_one l
    (* 6.5.3#2 Unary operators, Semantic: "The prefix [[ -- ]] operator is
       analogous to the prefix [[ ++ ]] operator". *)
    | c`UNARY c`PREFIX_DECR e ->
        a`ASSIGN (Some c`SUB) <$> f e <@> d_one l
    (* 6.5.3.3 Unary arithmetic operators, Semantics: "The expression [[ !E ]] is
       equivalent to [[ (E==0) ]]". *)
    | c`UNARY c`NOT e -> a`BINARY (c`RELATIONAL c`EQ) (d_zero l) <$> f e
    | c`UNARY unop e -> a`UNARY (desugar_unop unop) <$> f e
    | c`BINARY o e1 e2 -> a`BINARY o <$> f e1 <*> f e2
    | c`ASSIGN o e1 e2 -> a`ASSIGN o <$> f e1 <*> f e2
    | c`QUESTION e1 e2 e3 -> a`QUESTION <$> f e1 <*> f e2 <*> f e3
    | c`CAST t e -> a`CAST <$> ft t <*> f e
    | c`CALL e es -> a`CALL <$> f e <*> effect`map_list f es
    | c`CONSTANT c -> effect`unit (a`CONSTANT c)
    | c`VARIABLE n -> a`VARIABLE <$> subst l n
    | c`TYPE_SIZEOF t -> a`SIZEOF <$> ft t
    | c`TYPE_ALIGNOF t -> a`ALIGNOF <$> ft t
(*
    | c`COMPOUND_LITERAL _ ->
        raise_bug "Compound literals are not yet supported."
*)
  end)

| desugar_specifier specifiers =
  let mset = multiset`from_list in
  let smap =
    List`fold_left
      (fun m (x, y) -> Pmap`add x y m)
(* TODO
      (Pmap`create multiset`compare)
*)
      Pmap`empty
      ( [(mset [c`VOID], a`VOID)]
        @ [(mset [c`SIGNED; c`CHAR], a`INTEGER (a`SIGNED a`ICHAR))]
        @ [(mset [c`UNSIGNED; c`CHAR], a`INTEGER (a`UNSIGNED a`ICHAR))]
        @ List`map (fun s -> (mset s, a`INTEGER (a`SIGNED a`SHORT)))
          [ [c`SHORT];
            [c`SIGNED; c`SHORT];
            [c`SHORT; c`INT];
            [c`SIGNED; c`SHORT; c`INT]
          ]
        @ List`map (fun s -> (mset s, a`INTEGER (a`UNSIGNED a`SHORT)))
          [ [c`UNSIGNED; c`SHORT];
            [c`UNSIGNED; c`SHORT; c`INT]
          ]
        @ List`map (fun s -> (mset s, a`INTEGER (a`SIGNED a`INT)))
          [ [c`INT];
            [c`SIGNED];
            [c`SIGNED; c`INT]
          ]
        @ List`map (fun s -> (mset s, a`INTEGER (a`UNSIGNED a`INT)))
          [ [c`UNSIGNED];
            [c`UNSIGNED; c`INT]
          ]
        @ List`map (fun s -> (mset s, a`INTEGER (a`SIGNED a`LONG)))
          [ [c`LONG];
            [c`SIGNED; c`LONG];
            [c`LONG; c`INT];
            [c`SIGNED; c`LONG; c`INT]
          ]
        @ List`map (fun s -> (mset s, a`INTEGER (a`UNSIGNED a`LONG)))
          [ [c`UNSIGNED; c`LONG];
            [c`UNSIGNED; c`LONG; c`INT]
          ]
        @ List`map (fun s -> (mset s, a`INTEGER (a`SIGNED a`LONG_LONG)))
          [ [c`LONG; c`LONG];
            [c`SIGNED; c`LONG; c`LONG];
            [c`LONG; c`LONG; c`INT];
            [c`SIGNED; c`LONG; c`LONG; c`INT]
          ]
        @ List`map (fun s -> (mset s, a`INTEGER (a`UNSIGNED a`LONG_LONG)))
          [ [c`UNSIGNED; c`LONG; c`LONG];
            [c`UNSIGNED; c`LONG; c`LONG; c`INT]
          ]
        @ [(mset [c`BOOL], a`INTEGER a`BOOL)]
      ) in
  effect`of_option "" (map`find specifiers smap)

| desugar_type t =
  let ft = desugar_type in
  match t with
    | c`BASE qs ss -> a`BASE qs <$> desugar_specifier ss
    | c`ARRAY _ t (Some e) ->
        let size =
          match e with
            | (c`CONSTANT (c`CONST_INT (size, _)), _) -> effect`unit size
            | (_, l) ->
                let msg = "We don't support VLAs and moreover the size of an array \
                           must be an integer constant.\n" in
                effect`fail msg
(*
                CpLogger.error (CpPrint.pp_program msg) l;
*)
          end in
        a`ARRAY <$> ft t <*> size
    | c`ARRAY s t None -> effect`fail "Arrays are not yet supported.\n"
    | c`FUNCTION t decls ->
        let f ((_, t, sts), l) =
          desugar_storage l sts >>= (function
(* 
            | Some a`REGISTER ->
                raise_error "No support for storage class register."
*)
            | Some _ ->
                let msg = "Violation of constraint 6.7.6.3#2 Function declarators \
                           (including prototypes), Constraints: ``The only \
                           storage-class that shall occur in a parameter \
                           declaration is register.`` in\n" in
                effect`fail msg
(*
                CpLogger.info (CpPrint.pp_program msg) l;
                raise E_Invalid
*)
            | None -> ft t
          end) in
        let d_decls = effect`map_list f decls in
        a`FUNCTION <$> ft t <*> d_decls
    | c`POINTER qs t -> a`POINTER qs <$> ft t
  end

| desugar_stmt (s, l) =
  let fs = desugar_stmt in
  let fe = desugar_exp  in
  ail`Stmt l <$> match s with
    | c`BLOCK ss ->
        (* Open up a new scope, transform each statement/declaration in the
           block and tear down the scope again. *)
        effect`create_scope   >>= (fun ()   ->
        effect`map_list fs ss >>= (fun d_ss ->
        effect`symbols        >>= (fun ids  ->
        effect`destroy_scope  >>= (fun ()   ->
        effect`unit (a`BLOCK ids d_ss)))))
    (* We transform all for statements into while statements. *)
    | c`FOR_EXP e1_opt e2_opt e3_opt s ->
        let s1 =
          match e1_opt with
            | Some e1 -> (c`EXPRESSION e1, l)
            | None    -> (c`SKIP, l)
          end in
        let e2 =
          match e2_opt with
            | Some e2 -> e2
            (* According to 6.8.5.3#2 (Iteration statements, Semantics - The for
               statement) an omitted controlling expression is replace by an
               unspecified non-zero integer constant. We believe that the choice, as
               long as representable, does not matter with respect to the
               semantics. Hence, we arbitrarily choose "1" (which can always be
               represented as an object of type int). *)
            | None -> one l
          end in
        let s3 =
          match e3_opt with
            | Some e3 -> (c`EXPRESSION e3, l)
            | None    -> (c`SKIP, l)
          end in
        let body = (c`BLOCK [s; s3], l) in
        let loop = (c`WHILE e2 body, l) in    
        let s' = (c`BLOCK [s1; loop], l) in
        fs s' >>= (function ail`Stmt _ d_s ->
          effect`unit d_s
        end)
    | c`FOR_DECL defns e2_opt e3_opt s ->
        let is_auto_or_register ((((_, _, storage), l), _), _) =
          if List`exists (fun s -> s <> c`AUTO && s <> c`REGISTER) storage then
            false
(*
            CpLogger.info (CpPrint.pp_program msg) l;
            raise E_Invalid in
 *)
          else true in
        if not (List`for_all is_auto_or_register defns) then
          let msg = "Violation of constraint 6.8.5#3 Iteration statements, \
                     Constraints: ``The declaration part of a for statement \
                     shall only declare identifiers for objects having storage \
                     class auto or register`` in\n" in
          effect`fail msg
        else
          let s1 = (c`DECLARATION defns, l) in
          let e2 =
            match e2_opt with
              | Some e2 -> e2
              (* See comment above. *)
              | None -> one l
            end in
          let s3 =
            match e3_opt with
              | Some e3 -> (c`EXPRESSION e3, l)
              | None    -> (c`SKIP, l)
            end in
          let body = (c`BLOCK [s; s3], l) in
          let loop = (c`WHILE e2 body, l) in
          let s' = (c`BLOCK [s1; loop], l) in
          fs s' >>= (function ail`Stmt _ d_s ->
            effect`unit d_s
          end)
    | c`DECLARATION defns ->
        let d_defns = effect`map_list desugar_defn defns in
        (* We remove all declarations that don't contain an initialiser. *)
        let f = function
          | (id, Some d_e, _) -> Some (id, d_e)
          | (_,  None,     _) -> None
        end in
        a`DECLARATION <$> (list`filter_map f <$> d_defns)
    | c`EXPRESSION e -> a`EXPRESSION <$> fe e
    | c`IF e s1 s2_opt ->
        let d_s2 = desugar_stmt_opt l s2_opt in
        a`IF <$> fe e <*> fs s1 <*> d_s2
    | c`WHILE e s  -> a`WHILE  <$> fe e <*> fs s
    | c`DO    e s  -> a`DO     <$> fe e <*> fs s
    | c`SWITCH e s -> a`SWITCH <$> fe e <*> fs s
    | c`CASE (e, l) s ->
        let integer_constant =
          match e with
            | c`CONSTANT (c`CONST_INT i) -> effect`unit i
            | _ -> effect`fail "We don't support anything but integer \
                                constants as [[ case ]] labels."
          end in
        a`CASE <$> integer_constant <*> fs s
    | c`DEFAULT s -> a`DEFAULT <$> fs s
    | c`LABEL n s -> (* a`LABEL n (fs s) *)
        effect`fail "No support for labeled statements yet.\n"
    | c`RETURN (Some e) -> a`RETURN_EXPRESSION <$> fe e
    | c`RETURN None -> effect`unit a`RETURN_VOID
    | c`GOTO n -> effect`fail "No support for goto yet.\n"
    | c`SKIP -> effect`unit a`SKIP
    | c`BREAK -> effect`unit a`BREAK
    | c`CONTINUE -> effect`unit a`CONTINUE
  end

| desugar_stmt_opt l = function
  | Some stmt -> desugar_stmt stmt
  (* Adding or removing a (finite number of) null operation is semantically
     sound since "a null statement [...] performs no operations" (6.8.3#3,
     Expression and null statements, Semantics). *)
  | None -> effect`unit (ail`Stmt l a`SKIP)
end

| register_name l name =
  effect`return_scope >>= (fun scope ->
  if symbol_table`mem name scope then
    let msg = "Violation of constraint 6.7#3 Declarations, Constraints: ``If \
               an identifier has no linkage, there shall be no more than one \
               declaration of the identifier [...]`` in\n" in
    effect`fail msg
(*
    CpLogger.info (CpPrint.pp_program msg) l;
    raise E_Invalid
*)
  else
    effect`fresh_name name)

| desugar_storage l = function
  | []           -> effect`unit None
  | [c`AUTO]     -> effect`unit (Some a`AUTO)
  | [c`STATIC]   -> effect`unit (Some a`STATIC)
  | [c`REGISTER] -> effect`fail "No support for storage class register."
  | [c`EXTERN]   -> effect`fail "No support for storage class extern."
  | _ ->
      let msg =
        "Violation of constraint 6.7.1#1 Storage-class specifiers, Contraints: \
         ``At most, one storage-class specifier may be given [...]`` in\n" in
      effect`fail msg
(*
      CpLogger.info (CpPrint.pp_program msg) l;
      raise E_Invalid
*)
end

| desugar_decl ((name, t, sts), l) =
  register_name l name         >>= (fun id   ->
  desugar_storage l sts        >>= (fun d_st ->
  desugar_type t               >>= (fun d_t  ->
  effect`add_id id (d_t, d_st) >>= (fun ()   ->
  effect`unit id))))

| desugar_function_decl ((name, t, sts), l) =
  let desugar_function_type t =
    match t with
      | c`FUNCTION t decls ->
          let f ((name, t, sts), l) (ids, ds) =
            register_name l name  >>= (fun id  ->
            desugar_type t        >>= (fun d_t ->
            desugar_storage l sts >>= (function
              (*
              | Some a`REGISTER ->
                  effect`fail "No support for storage class register."
              *)
              | Some _ ->
                  let msg = "Violation of constraint 6.7.6.3#2 Function \
                             declarators (including prototypes), Constraints: \
                             ``The only storage-class that shall occur in a \
                             parameter declaration is register.`` in\n" in
                  effect`fail msg
(*
                  CpLogger.info (CpPrint.pp_program msg) l;
                  raise E_Invalid
*)
              | None -> effect`unit None
            end) >>= (fun d_st ->
            effect`add_id id (d_t, d_st) >>= (fun () ->
            effect`unit (id::ids, d_t::ds))))) in
          let f _ b = effect`unit b in
          desugar_type t >>= (fun d_t ->
          effect`foldr_list f decls ([], []) >>= (fun (formals, d_decls) ->
          effect`unit (a`FUNCTION d_t d_decls, formals)))
      | _ -> effect`fail "Not a function type."
    end in
  register_name l name         >>= (fun id ->
  desugar_storage l sts        >>= (fun d_st ->
  effect`create_scope          >>= (fun () ->
  desugar_function_type t      >>= (fun (d_t, formals) ->
  effect`return_scope          >>= (fun fn_scope ->
  effect`destroy_scope         >>= (fun () ->
  effect`add_id id (d_t, d_st) >>= (fun () ->
  effect`push_table fn_scope   >>= (fun () ->
  effect`unit (id, formals)))))))))

| desugar_defn ((d, e_opt), l) =
  desugar_decl d >>= (fun id ->
  match e_opt with
    | None -> effect`unit (id, None, l)
    | Some e ->
        desugar_exp e >>= (fun d_e ->
        effect`unit (id, Some d_e, l))
  end)

let desugar_global_defn (defn, l) =
  match defn with
    | c`FUNCTION_DEFINITION decl s ->
         desugar_function_decl decl >>= (fun (id, formals) ->
        desugar_stmt s >>= (fun d_s ->
        effect`destroy_scope >>= (fun () ->
        effect`add_fn id formals d_s)))
    | c`EXTERNAL_DECLARATION defns ->
        let f = function
          | (id, Some e, l) -> (id, e)
          | (id, None,   l) -> (id, d_zero l)
        end in
        List`map f <$> effect`map_list desugar_defn defns >>= (fun d_defns ->
        effect`add_globals d_defns)
   end

let desugar_program startup global_defns =
  let msg = "Could not find startup function ``" ^ startup ^ "``.\n" in
  effect`iter desugar_global_defn global_defns >>= (fun () ->
  effect`option msg (effect`resolve "main") >>= (fun main ->
(*
      CpLogger.info (fun x -> x) msg;
      raise E_Invalid in
*)
    effect`to_program main))

let desugar startup (name, global_defns) =
  let init = effect`initial_state in
  desugar_program startup global_defns init
(*
  | E_Undefined -> a`Undefined
  | E_Invalid -> a`Invalid
*)