open global

type ('a, 'msg) t =
  | Result of 'a
  | Error  of 'msg

let bind m k =
  match m with
    | Result a -> k a
    | Error  s -> Error s
  end

let unit a = Result a
let fail m = Error m
let join m = bind m (fun x -> x)

let map f m = bind m (unit -| f)

let app mf m = bind mf (fun f -> map f m)

let app2 mf mx my = app (app mf mx) my
let app3 mf mx my mz = app (app (app mf mx) my) mz

let map2 f mx my = app (map f mx) my
let map3 f mx my mz = app2 (map f mx) my mz

let map_list f xs =
  List`fold_right (fun x -> map2 list`cons (f x)) xs (unit [])

let map_snd_list f init xs =
  let f' x (i, ys) =
    let (i, y) = f i x in
    (i, y::ys) in
  let mys_rev = List`fold_left (fun m x -> map (f' x) m) (unit (init, [])) xs in
  map (pair`app_right List`rev) mys_rev

let map_snd_list_alt f init xs =
  let f' (i, mys) x =
    let (i, my) = f i x in
    (i, map2 list`cons my mys) in
  let mys_rev = List`fold_left f (init, unit []) xs in
  pair`app_right (map List`rev) mys_rev

let of_option m = function
  | Some a -> unit a
  | None   -> fail m
end

module Operators = struct
  let (>>=) = bind
end