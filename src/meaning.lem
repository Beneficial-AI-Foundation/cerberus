open global

module c = constraint

type denotation = <|
  actions     : action`t set;
  constraints : c`t;
  seq_before  : (action`t * action`t) set;
  fs_actions  : (action`t, action`t set) map
|>

module denotation = struct
  type t = denotation
  let compare d1 d2 =
    let (++) n p = if n = 0 then p else n in
    Set`compare d1.actions d2.actions
    ++ c`compare d1.constraints d2.constraints
    ++ Set`compare d1.seq_before d2.seq_before
    ++ Pmap`compare Set`compare d1.fs_actions d2.fs_actions
end

(*
module DS = Set`Make(Denotation)

type t = DS.t
*)

type t = denotation`t set

type func = <|
  break    : t;
  continue : t;
  normal   : t;
  return   : t
|>

let init = {<|
  actions     = empty;
  constraints = empty;
  seq_before  = empty;
  fs_actions  = Pmap`empty
|>}

let none = empty

let and_denotations d1 d2 = <|
  actions     = d1.actions     union d2.actions;
  constraints = d1.constraints union d2.constraints;
  seq_before  = d1.seq_before  union d2.seq_before;
  fs_actions  = Pmap`union d1.fs_actions d2.fs_actions
|>

let and_denotations_sb d1 d2 = <|
  actions     = d1.actions union d2.actions;
  constraints = d1.constraints union d2.constraints;
  seq_before  =
    let sb = set`product d1.actions d2.actions in
    sb union (d1.seq_before union d2.seq_before);
  fs_actions  = Pmap`union d1.fs_actions d2.fs_actions
|>

let conj t1 t2 = set`product_map and_denotations t1 t2
let conj_seq_before t1 t2 = set`product_map and_denotations_sb t1 t2

let add_constraint t cstr =
  {<|d with constraints = d.constraints union {cstr}|> | forall (d IN t) | true}

let add_constraint_set t c =
  {<|d with constraints = d.constraints union c|> | forall (d IN t) | true}

let add_action t a =
  {<|d with actions = d.actions union {a}|> | forall (d IN t) | true}

let add_actions t acts =
  {<|d with actions = d.actions union acts|> | forall (d IN t) | true}

module operators = struct
  let (|&|) = conj
  let (|&>) = conj_seq_before
  let (|||) = (union)
  let (<&-) = add_constraint
  let (<@-) = add_action
end

let init_func = <|
  break    = empty;
  continue = empty;
  normal   = init;
  return   = empty
|>

let break t = <|
  break    = t;
  continue = empty;
  normal   = empty;
  return   = empty
|>

let continue t = <|
  break    = empty;
  continue = t;
  normal   = empty;
  return   = empty
|>

let normal t = <|
  break    = empty;
  continue = empty;
  normal   = t;
  return   = empty
|>

let return t = <|
  break    = empty;
  continue = empty;
  normal   = empty;
  return   = t
|>

let collect_fs_actions m =
  let call = action`call in
  let add_call d = <|d with
    actions    = {call};
    fs_actions = Pmap`add call d.actions d.fs_actions
  |> in
  {add_call d | forall (d IN m) | true}     

let flatten_func m =
  let open operators in
  collect_fs_actions (m.normal <&- c`undef ||| m.return)

let enter_loop t_pos t_neg m =
  let open operators in
  let t = m.continue ||| m.normal in <|
    break    = m.break ||| (t |&> t_neg);
    continue = m.empty;
    normal   = t |&> t_pos;
    return   = m.return
  |>

let exit_loop t_neg m =
  let open operators in <|init_func with
    normal = m.break ||| ((m.continue ||| m.normal) |&> t_neg);
    return = m.return
  |>

let conj_seq_before_func m1 m2 =
  let open operators in <|
    break    = m1.break    ||| (m1.normal |&> m2.break);
    continue = m1.continue ||| (m1.normal |&> m2.continue);
    normal   = m1.normal   |&> m2.normal;
    return   = m1.return   ||| (m1.normal |&> m2.return)
  |>

let disj_func m1 m2 =
  let open operators in <|
    break    = m1.break    ||| m2.break;
    continue = m1.continue ||| m2.continue;
    normal   = m1.normal   ||| m2.normal;
    return   = m1.return   ||| m2.return
  |>

let add_constraint_func m c =
  let open operators in
  <|m with normal = m.normal <&- c|>

let add_action_func m a =
  let open operators in
  <|m with normal = m.normal <@- a|>

let add_action_entire_func m a =
  let open operators in <|
    break    = m.break    <@- a;
    continue = m.continue <@- a;
    normal   = m.normal   <@- a;
    return   = m.return   <@- a
  |>

let add_actions_entire_func_sb m actions =
  let open operators in
  let t = {<|d with actions = actions|> | forall (d in init) | true} in <|
    break = m.break       |&> t;
    continue = m.continue |&> t;
    normal = m.normal     |&> t;
    return = m.return     |&> t
  |>

let add_constraint_entire_func m c =
  let open operators in <|
    break    = m.break    <&- c;
    continue = m.continue <&- c;
    normal   = m.normal   <&- c;
    return   = m.return   <&- c
  |>

module statement_operators = struct
  (* OCaml won't allow us to define (\/) and (/\). *sniff* *)
  let (|&>) = conj_seq_before_func
  let (|||) = disj_func
  let (<&-) = add_constraint_entire_func
  let (<@-) = add_action_func
end

module print = struct
  module p = pprint
  module u = pprint`unicode

  open p`operators

  let nbraces d = p`lbrace ^^ p`group2 (p`break0 ^^ d) ^/^ p`rbrace

  let pp_set pp s  =
    nbraces (p`comma_list pp (Set`elements  s))
  let pp_dset pp s =
    let sep = p`comma ^^ p`break1 in
    let pp_b e = nbraces (pp e) in
    p`sepmap sep pp_b (Set`elements s)

  let pp_actions = pp_set action`print`pp
  let pp_contraints = c`print.pp
  let pp_action_id = action`print`pp_uid
  let pp_seq_before =
    let pp_a = pp_action_id in
    pp_set (fun (a1, a2) -> pp_a a1 ^^^ U.implies ^^^ pp_a a2)
  let pp_fs_actions m =
    let pp_a = pp_action_id in
    nbraces (
      p`comma_list
        (fun (a, b) -> pp_a a ^^^ U.mapsto ^^^ pp_actions b)
        (M.bindings m)
    )

  let pp_denot <|actions; constraints; seq_before; fs_actions|> =
    let line name pp p = !^ name ^^^ p`equals ^^^ p`group (pp p) ^^ p`semi in
    line "actions" pp_actions actions
    ^/^ line "constraints"      pp_contraints constraints
    ^/^ line "sequenced_before" pp_seq_before seq_before
    ^/^ line "function_actions" pp_fs_actions fs_actions

  let pp m = nbraces (pp_dset pp_denot m) ^^ p`break0
end

module solve = struct
  type trace = c`t * action`t list

  let schedule pre s =
    let action = [a | forall (a IN s) | true] in
    match pre with
      | [] -> [actions]
      | _  -> [ls @ actions | forall (ls MEM pre) | true]
    end

  let partition_sb d u =
    let sa a u = exists (a' IN u). (a', a) IN d.seq_before in
    Set`partition (fun a -> not (sa a u)) u

  let permute sb ts =
    let rec p t lls front tail =
      match tail with
      | [] -> (front @ [t]) :: lls
      | a::rest -> p t ((front @ (t :: tail)) :: lls) (front @ [a]) rest in
    let combine t lls ls =
      let rec split p front tail =
        match tail with
        | [] -> front, []
        | a::rest ->
            if p a then
              front, tail
            else
              split p (front @ [a]) rest in
      let split_sb = split (fun a -> (a, t) IN sb) in
      let split_sa = split (fun a -> (t, a) IN sb) in
      let (rest, sa) = split_sa [] ls in
      let (nu, bs) = split_sb [] (List`rev rest) in
      let sb = List`rev bs in
      let un = List`rev nu in
      let sb_un = List`map ((@) sb) (p t lls [] un) in
      List`map ((@) sa) sb_un in
    let step t lls = List`fold_left (combine t) [] lls in
    Set`fold step ts [[]]

  let partition sb cs es =
    let rec f e lls cs front tail =
      match cs, tail with
      | ([], [a]) -> (front @ [e :: a]) :: lls
      | (c::cs', a::rest) ->
          let lls' = (front @ ((e :: a) :: rest)) :: lls in
          if (e, c) IN sb || List`exists (fun t -> (e, t) IN sb) a then
            lls'
          else
            if action`is_access e && not (action`is_fn_store e) then
              f e lls' cs' (front @ [a]) rest
            else
              f e lls  cs' (front @ [a]) rest in
    let step lls e =
      List`fold_left (fun lls ls -> f e lls cs [] ls) [] lls in
    List`fold_left step [List`make (1 + List`length cs) []] es
(*
  let rec merge d pre perm part =
    match perm, part with
    | [], [ts] -> schedule pre ts
    | c::cs, ts::tss ->
        let combine_pres (c1, ls1) (c2, ls2) = (c1 union c2, ls1 @ ls2) in
        merge d (schedule (List`product_map combine_pres pre c) ts) cs tss
    | _ -> assert (false)
*)

  let rec seq d pre future =
    if Set`is_empty future then
      pre
    else
      let (sb, sa) = partition_sb d future in
      let (sb_calls, sb_rest) = Set`partition action`is_call sb in
      let (sa_ucalls, sa_rest) =
        Set`partition
          (fun a -> 
            action`is_call a && exists a' IN sb. not ((a',a) IN d.seq_before)
          ) sa in
      let calls = sb_calls union sa_ucalls in
      if Set`is_empty calls then
        seq d (schedule pre sb) sa
      else
        let sb_accesses, sb_other = Set`partition action`is_access sb_rest in
        let pre = schedule pre sb_other in
        let (sa_rest_todo, sa_rest_rest) =
          Set`partition
            (fun a -> exists (c IN calls).
              (a, c) IN d.seq_before || not ((c, a) IN d.seq_before)
            ) sa_rest in
        let todo_list =
          let rec f ls t =
            if Set`is_empty t then
              ls
            else
              let sb, sa =
                Set`partition
                  (fun a -> forall (a' in t). not ((a', a) IN d.seq_before))
                  t in
              f (Set`elements sb @ ls) sa in
          f [] (sb_accesses union sa_rest_todo) in
        let call_map =
          let seq_call c = seq d [] (M.find c d.fs_actions) in
          Pmap`of_list [(c, seq_call c) | forall (c IN calls) | true] in
        let perm = permute d.seq_before calls in
        let rec interleave pre cs ts =
          let add_trace t = [p @ t | forall (p MEM pre) | true] in
          match (cs, ts) with
            | ([], [t]) -> add_trace t
            | (c::cs', t::ts) ->
                let pre = list`product_map (@) (add_trace t) (M.find c call_map) in
                interleave pre cs' ts
          end in
        let merge lls cs =
          let part = partition d.seq_before cs todo_list in
          List`fold_left (fun lls ts -> interleave pre cs ts @ lls) lls part in
        seq d (List`fold_left merge [] perm) sa_rest_rest

  let linearise d = seq d [] d.actions

  let simplify d c =
    let module p = c`process in
    let conflicts =
      Pmap`fold
        (fun ts c -> c union (action`conflicts d.seq_before ts))
        d.fs_actions empty in
    try
      let p = p`make d.constraints in
      let p = p`union p conflicts in
      let f c trace =
        try
(*
          Set`add (action`memory`replay p trace) c
*)
          (action`memory`replay p trace) :: c
        with
        | p`Partial _ -> assert (false)
        | p`Invalid -> c in
      List`fold_left f c (linearise d)
    with p`Invalid -> c
(*
      List`fold_left f (Set`create c`compare) traces
    with p`Invalid -> Set`create c`compare
*)

  let simplify_all t = Set`of_list (*~cmp:c`compare*) (Set`fold simplify t [])

  let simplify_result = function
    | Ail.Program t -> Ail.Program (simplify_all t)
    | Ail.Invalid -> Ail.Invalid
    | Ail.Undefined -> Ail.Undefined
end

module Graph = struct
  let dot n t =
    Set`fold
      (fun d i ->
        let name = n ^ "." ^ (BatInt.to_string i) ^ ".dot" in
        let doc = action`print`pp_dot d.seq_before in
        let str = Document.to_plain_string doc in
        let () = Output.write str (Output.file name) in
        i + 1
      ) t 0
  let dot_result n = function
    | Ail.Program t -> ignore (dot n t)
    | _ -> ()
end
