open global

module c = constraint

type denotation = <|
  actions     : action`t set;
  constraints : c`t;
  seq_before  : (action`t * action`t) set;
  fs_actions  : (action`t, action`t set) map
|>

module denotation = struct
  type t = denotation
  let compare d1 d2 =
    let (++) n p = if n = 0 then p else n in
    Set`compare d1.actions d2.actions
    ++ c`compare d1.constraints d2.constraints
    ++ Set`compare d1.seq_before d2.seq_before
    ++ Pmap`compare Set`compare d1.fs_actions d2.fs_actions
end

type t = denotation`t set

type t_lifted = <|
  break    : t;
  continue : t;
  normal   : t;
  return   : t
|>

let init = {<|
  actions     = empty;
  constraints = empty;
  seq_before  = empty;
  fs_actions  = Pmap`empty
|>}

let none = empty

let and_denotations d1 d2 = <|
  actions     = d1.actions     union d2.actions;
  constraints = d1.constraints union d2.constraints;
  seq_before  = d1.seq_before  union d2.seq_before;
  fs_actions  = Pmap`concat d1.fs_actions d2.fs_actions
|>

let and_denotations_sb d1 d2 = <|
  actions     = d1.actions union d2.actions;
  constraints = d1.constraints union d2.constraints;
  seq_before  =
    let sb = set`product d1.actions d2.actions in
    sb union (d1.seq_before union d2.seq_before);
  fs_actions  = Pmap`concat d1.fs_actions d2.fs_actions
|>

let conj m1 m2 = set`product_map and_denotations m1 m2
let conj_seq_before m1 m2 = set`product_map and_denotations_sb m1 m2

let add_constraint m cstr =
  {<|d with constraints = d.constraints union {cstr}|> | forall (d IN m) | true}

let add_constraint_set m c =
  {<|d with constraints = d.constraints union c|> | forall (d IN m) | true}

let add_action m a =
  {<|d with actions = d.actions union {a}|> | forall (d IN m) | true}

let add_actions m acts =
  {<|d with actions = d.actions union acts|> | forall (d IN m) | true}

module operators = struct
  let (-&-) = conj
  let (-&>) = conj_seq_before
  let (</>) = (union)
  let (+&) = add_constraint
  let (+@) = add_action
  let (-@>) m a = m -&> (init +@ a)
end

let init_lifted = <|
  break    = empty;
  continue = empty;
  normal   = init;
  return   = empty
|>

let break m = <|
  break    = m;
  continue = empty;
  normal   = empty;
  return   = empty
|>

let continue m = <|
  break    = empty;
  continue = m;
  normal   = empty;
  return   = empty
|>

let normal m = <|
  break    = empty;
  continue = empty;
  normal   = m;
  return   = empty
|>

let return m = <|
  break    = empty;
  continue = empty;
  normal   = empty;
  return   = m
|>

let collect_fs_actions m =
  let call = action`call in
  let add_call d = <|d with
    actions    = {call};
    fs_actions = Pmap`add call d.actions d.fs_actions
  |> in
  {add_call d | forall (d IN m) | true}     

let flatten ml =
  collect_fs_actions (ml.normal +& c`undef -/- ml.return)

let enter_loop m_pos m_neg ml =
  let m = ml.continue -/- ml.normal in <|
    break    = ml.break -/- (m -&> m_neg);
    continue = empty;
    normal   = m -&> m_pos;
    return   = ml.return
  |>

let exit_loop m_neg l =
  <|init_lifted with
    normal = ml.break -/- ((ml.continue -/- ml.normal) -&> m_neg);
    return = ml.return
  |>

let conj_seq_before_lifted ml1 ml2 =
  <|break    = ml1.break    -/- (ml1.normal -&> ml2.break);
    continue = ml1.continue -/- (ml1.normal -&> ml2.continue);
    normal   = ml1.normal   -&> ml2.normal;
    return   = ml1.return   -/- (ml1.normal -&> ml2.return)
  |>

let disj_lifted ml1 ml2 =
  <|break    = ml1.break    -/- ml2.break;
    continue = ml1.continue -/- ml2.continue;
    normal   = ml1.normal   -/- ml2.normal;
    return   = ml1.return   -/- ml2.return
  |>

let add_constraint_lifted ml c = <|ml with normal = ml.normal +& c|>

let add_action_lifted     ml a = <|ml with normal = ml.normal +@ a|>

let add_action_entire_lifted ml a =
  <|break    = ml.break    +@ a;
    continue = ml.continue +@ a;
    normal   = ml.normal   +@ a;
    return   = ml.return   +@ a
  |>

let add_actions_entire_lifted_sb ml actions' =
  let m = {<|d with actions = actions'|> | forall (d IN init) | true} in <|
    break    = ml.break    -&> m;
    continue = ml.continue -&> m;
    normal   = ml.normal   -&> m;
    return   = ml.return   -&> m
  |>

let add_constraint_entire_lifted ml c =
  <|break    = ml.break    +& c;
    continue = ml.continue +& c;
    normal   = ml.normal   +& c;
    return   = ml.return   +& c
  |>

module statement_operators = struct
  (* OCaml won't allow us to define (\/) and (/\). *sniff* *)
  let (--&>) = conj_seq_before_lifted
  let (-//-) = disj_lifted
  let (++&)  = add_constraint_entire_lifted
  let (++@)  = add_action_lifted
end

module print = struct
  module p = pprint
  module u = pprint`unicode

  open p`operators

  let nbraces d = p`lbrace ^^ p`group2 (p`break0 ^^ d) ^/^ p`rbrace

  let pp_set pp s  =
    nbraces (p`comma_list pp (Set`elements  s))
  let pp_dset pp s =
    let sep = p`comma ^^ p`break1 in
    let pp_b e = nbraces (pp e) in
    p`sepmap sep pp_b (Set`elements s)

  let pp_actions = pp_set action`print`pp
  let pp_contraints = c`print.pp
  let pp_action_id = action`print`pp_uid
  let pp_seq_before =
    let pp_a = pp_action_id in
    pp_set (fun (a1, a2) -> pp_a a1 ^^^ U.implies ^^^ pp_a a2)
  let pp_fs_actions m =
    let pp_a = pp_action_id in
    nbraces (
      p`comma_list
        (fun (a, b) -> pp_a a ^^^ U.mapsto ^^^ pp_actions b)
        (M.bindings m)
    )

  let pp_denot t =
    let line name pp p = !^ name ^^^ p`equals ^^^ p`group (pp p) ^^ p`semi in
    line "actions" pp_actions t.actions
    ^/^ line "constraints"      pp_contraints t.constraints
    ^/^ line "sequenced_before" pp_seq_before t.seq_before
    ^/^ line "function_actions" pp_fs_actions t.fs_actions

  let pp m = nbraces (pp_dset pp_denot m) ^^ p`break0
end

module solve = struct
  type trace = c`t * action`t list

  let schedule pre s =
    let action = [a | forall (a IN s) | true] in
    match pre with
      | [] -> [actions]
      | _  -> [ls @ actions | forall (ls MEM pre) | true]
    end

  let partition_sb d u =
    let sa a u = exist (a' IN u). (a', a) IN d.seq_before in
    Set`partition (fun a -> not (sa a u)) u

  let rec perm t lls front tail =
    match tail with
      | [] -> (front @ [t]) :: lls
      | a::rest -> perm t ((front @ (t :: tail)) :: lls) (front @ [a]) rest
  end

  let rec split p front tail =
    match tail with
      | [] -> (front, [])
      | a::rest ->
          if p a
            then (front, tail)
            else split p (front @ [a]) rest 
    end

  let permute sb ts =
    let combine t lls ls =
      let split_sb = split (fun a -> (a, t) IN sb) in
      let split_sa = split (fun a -> (t, a) IN sb) in
      let (rest, sa) = split_sa [] ls in
      let (nu, bs) = split_sb [] (List`rev rest) in
      let sb = List`rev bs in
      let un = List`rev nu in
      let sb_un = List`map ((@) sb) (perm t lls [] un) in
      List`map ((@) sa) sb_un in
    let step t lls = List`fold_left (combine t) [] lls in
    Set`fold step ts [[]]

  let rec part e lls cs front tail =
    match (cs, tail) with
      | ([], [a]) -> (front @ [e :: a]) :: lls
      | (c::cs', a::rest) ->
          let lls' = (front @ ((e :: a) :: rest)) :: lls in
          if (e, c) IN sb || (exist (t MEM a). (e, t) IN sb) then
            lls'
          else
            if action`is_access e && not (action`is_fn_store e) then
              part e lls' cs' (front @ [a]) rest
            else
              part e lls  cs' (front @ [a]) rest
    end

  let partition sb cs es =
    let step lls e =
      List`fold_left (fun lls ls -> f e lls cs [] ls) [] lls in
    List`fold_left step [List`make (1 + List`length cs) []] es
(*
  let rec merge d pre perm part =
    match (perm, part) with
    | [], [ts] -> schedule pre ts
    | c::cs, ts::tss ->
        let combine_pres (c1, ls1) (c2, ls2) = (c1 union c2, ls1 @ ls2) in
        merge d (schedule (List`product_map combine_pres pre c) ts) cs tss
    | _ -> assert (false)
*)

  let rec interleave pre cs ts =
    let add_trace t = [p @ t | forall (p MEM pre) | true] in
      match (cs, ts) with
        | ([], [t])        -> add_trace t
        | (c::cs', t::ts') ->
            let pre = list`product_map (@) (add_trace t) (M`find c call_map) in
            interleave pre cs' ts'
      end

  let rec make_todo d ls t =
    if t = empty then
      ls
    else
      let (sb, sa) =
        Set`partition
          (fun a -> (forall (a' IN t). not ((a', a) IN d.seq_before))) t in
      make_todo (Set`elements sb @ ls) sa

  let rec seq d pre future =
    if future = empty then
      pre
    else
      let (sb, sa) = partition_sb d future in
      let (sb_calls, sb_rest) = Set`partition action`is_call sb in
      let (sa_ucalls, sa_rest) =
        Set`partition
          (fun a -> 
            action`is_call a && (exist (a' IN sb). not ((a',a) IN d.seq_before))
          ) sa in
      let calls = sb_calls union sa_ucalls in
      if Set`is_empty calls then
        seq d (schedule pre sb) sa
      else
        let (sb_accesses, sb_other) = Set`partition action`is_access sb_rest in
        let pre = schedule pre sb_other in
        let (sa_rest_todo, sa_rest_rest) =
          Set`partition
            (fun a -> exist (c IN calls).
              (a, c) IN d.seq_before || not ((c, a) IN d.seq_before)
            ) sa_rest in
        let todo_list = make_todo d [] (sb_accesses union sa_rest_todo) in
        let call_map =
          let seq_call c = seq d [] (M`find c d.fs_actions) in
          Pmap`of_list [(c, seq_call c) | forall (c IN calls) | true] in
        let perms = permute d.seq_before calls in
        let merge lls cs =
          let parts = partition d.seq_before cs todo_list in
          List`fold_left (fun lls ts -> interleave pre cs ts @ lls) lls parts in
        seq d (List`fold_left merge [] perms) sa_rest_rest

  let linearise d = seq d [] d.actions

  module p = c`process

  let simplify d c =
    let conflicts =
      Pmap`fold
        (fun ts c -> c union (action`conflicts d.seq_before ts))
        d.fs_actions empty in
    let p = p`make d.constraints in
    let p = p`concat p conflicts in
    let f c trace = (action`memory`replay p trace) :: c in
    List`fold_left f c (linearise d)

  let simplify_all t = Set`of_list (Set`fold simplify t [])
end

module Graph = struct
  let dot n t =
    Set`fold
      (fun d i ->
        let name = n ^ "." ^ (string_of_num i) ^ ".dot" in
        let doc  = action`print`pp_dot d.seq_before in
        let str  = document`to_plain_string doc in
        let ()   = output`write str (output`file name) in
        i + 1
      ) t 0
end
