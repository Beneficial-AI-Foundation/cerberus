open global

module c = constraint

type denotation = {
  actions : action`t set;
  constraints : c`t;
  seq_before : (action`t * action`t) set;
  fs_actions : (action`t, action`t set) map
}

module denotation = struct
  type t = denotation
  let compare d1 d2 =
    let (++) n p = if n = 0 then p else n in
    Set`compare d1.actions d2.actions
    ++ c`compare d1.constraints d2.constraints
    ++ Set`compare d1.seq_before d2.seq_before
    ++ Pmap`compare Set`compare d1.fs_actions d2.fs_actions
end

(*
module DS = Set`Make(Denotation)

type t = DS.t
*)

type t = denotation`t set

type func = {
  break : t;
  continue : t;
  normal : t;
  return : t
}

let empty =
  Set`singleton (*~cmp:cmp*) {
    actions = Set`empty;
    constraints = c`empty;
    seq_before = Set`empty;
    fs_actions = Pmap`empty
  }

let none = Set`empty

let and_denotations d1 d2 = {
  actions = Set`union d1.actions d2.actions;
  constraints = c`union d1.constraints d2.constraints;
  seq_before = Set`union d1.seq_before d2.seq_before;
  fs_actions = Pmap`union d1.fs_actions d2.fs_actions
}

let and_denotations_sb d1 d2 = {
  actions = Set`union d1.actions d2.actions;
  constraints = c`union d1.constraints d2.constraints;
  seq_before =
    begin
      let sb = Set`product d1.actions d2.actions in
      Set`union sb (Set`union d1.seq_before d2.seq_before)
    end;
  fs_actions = Pmap`union d1.fs_actions d2.fs_actions
}

let product_map pair s1 s2 =
  let fold_inner a s_init =
    Set`fold (fun b s -> Set`add (pair a b) s) s2 s_init in
  Set`fold (fun a s -> fold_inner a s) s1 Set`empty

let conj m1 m2 = product_map and_denotations m1 m2
let conj_seq_before m1 m2 = product_map and_denotations_sb m1 m2
let disj m1 m2 = Set`union m1 m2

let add_constraint m constr =
  let c = c`make constr in
  Set`map (fun d -> {d with constraints = c`union d.constraints c}) m

let add_constraint_set m c =
  Set`map (fun d -> {d with constraints = c`union d.constraints c}) m

let add_action m a =
  Set`map (fun d -> {d with actions = Set`add a d.actions}) m

module operators = struct
  let (<&>) = conj
  let (&>>) = conj_seq_before
  let (<|>) = disj
  let (<&-) = add_constraint
  let (<@-) = add_action
end

let empty_func = {
  break = Set`empty;
  continue = Set`empty;
  normal = empty;
  return = Set`empty
}

let break m = {
  break = m;
  continue = Set`empty;
  normal = Set`empty;
  return = Set`empty
}

let continue m = {
  break = Set`empty;
  continue = m;
  normal = Set`empty;
  return = Set`empty
}

let normal m = {
  break = Set`empty;
  continue = Set`empty;
  normal = m;
  return = Set`empty
}

let return m = {
  break = Set`empty;
  continue = Set`empty;
  normal = Set`empty;
  return = m
}

let collect_fs_actions =
  Set`map (fun d ->
    let call = action`call () in
    {d with
      actions = Set`singleton call;
      fs_actions = Pmap`add call d.actions d.fs_actions
    }
  )

let flatten_func {break; continue; normal; return} =
  let open operators in
      assert (Set`is_empty break);
      assert (Set`is_empty continue);
      collect_fs_actions (normal <&- c`undef <|> return)

let enter_loop m_pos m_neg {break; continue; normal; return} =
  let open operators in
      let m = continue <|> normal in {
        break = break <|> (m &>> m_neg);
        continue = Set`empty;
        normal = m &>> m_pos;
        return = return
      }

let exit_loop m_neg {break; continue; normal; return} =
  let open operators in {empty_func with
    normal = break <|> ((continue <|> normal) &>> m_neg);
    return = return
  }

let conj_seq_before_func ml1 ml2 =
  let open operators in {
    break = ml1.break <|> (ml1.normal &>> ml2.break);
    continue = ml1.continue <|> (ml1.normal &>> ml2.continue);
    normal = ml1.normal &>> ml2.normal;
    return = ml1.return <|> (ml1.normal &>> ml2.return)
  }

let disj_func ml1 ml2 =
  let open operators in {
    break = ml1.break <|> ml2.break;
    continue = ml1.continue <|> ml2.continue;
    normal = ml1.normal <|> ml2.normal;
    return = ml1.return <|> ml2.return
  }

let add_constraint_func ml c =
  let open operators in
      {ml with normal = ml.normal <&- c}

let add_action_func ml a =
  let open operators in
      {ml with normal = ml.normal <@- a}

let add_action_entire_func {break; continue; normal; return} a =
  let open operators in {
    break = break <@- a;
    continue = continue <@- a;
    normal = normal <@- a;
    return = return <@- a
  }

let add_actions_entire_func_sb {break; continue; normal; return} actions =
  let open operators in
  let m = Set`map (fun d -> {d with actions = actions} ) empty in {
    break = break &>> m;
    continue = continue &>> m;
    normal = normal &>> m;
    return = return &>> m
  }

let add_constraint_entire_func {break; continue; normal; return} c =
  let open operators in {
    break = break <&- c;
    continue = continue <&- c;
    normal = normal <&- c;
    return = return <&- c
  }

module Statementoperators = struct
  (* OCaml won't allow us to define (\/) and (/\). *sniff* *)
  let (&>>) = conj_seq_before_func
  let (<|>) = disj_func
  let (<&-) = add_constraint_entire_func
  let (<@-) = add_action_func
end

module Print = struct
  module p = pprint
  module u = pprint`unicode

  open p`operators

  let nbraces d = p`lbrace ^^ p`group2 (p`break0 ^^ d) ^/^ p`rbrace

  let pp_set pp s  =
    nbraces (p`comma_list pp (Set`elements  s))
  let pp_dset pp s =
    let sep = p`comma ^^ p`break1 in
    let pp_b e = nbraces (pp e) in
    p`sepmap sep pp_b (Set`elements s)

  let pp_actions = pp_set action`print`pp
  let pp_contraints = c`Print.pp
  let pp_action_id = action`print`pp_uid
  let pp_seq_before =
    let pp_a = pp_action_id in
    pp_set (fun (a1, a2) -> pp_a a1 ^^^ U.implies ^^^ pp_a a2)
  let pp_fs_actions m =
    let pp_a = pp_action_id in
    nbraces (
      p`comma_list
        (fun (a, b) -> pp_a a ^^^ U.mapsto ^^^ pp_actions b)
        (M.bindings m)
    )

  let pp_denot {actions; constraints; seq_before; fs_actions} =
    let line name pp p = !^ name ^^^ p`equals ^^^ p`group (pp p) ^^ p`semi in
    line "actions" pp_actions actions
    ^/^ line "constraints" pp_contraints constraints
    ^/^ line "sequenced_before" pp_seq_before seq_before
    ^/^ line "function_actions" pp_fs_actions fs_actions

  let pp m = nbraces (pp_dset pp_denot m) ^^ p`break0
end

module Solve = struct
  type trace = c`t * action`t list

  let schedule pre s =
    match pre with
    | [] -> [Set`fold (fun a ls -> a :: ls) s []]
    | _ ->
        let pre_f a ls = ls @ [a] in
        Set`fold (fun a pre -> List.map (pre_f a) pre) s pre

  let partition_sb d u =
    let sa a u = Set`exists (fun a' -> Set`mem (a', a) d.seq_before) u in
    Set`partition (fun a -> not (sa a u)) u

  let permute sb ts =
    let rec p t lls front tail =
      match tail with
      | [] -> (front @ [t]) :: lls
      | a::rest -> p t ((front @ (t :: tail)) :: lls) (front @ [a]) rest in
    let combine t lls ls =
      let rec split p front tail =
        match tail with
        | [] -> front, []
        | a::rest ->
            if p a then
              front, tail
            else
              split p (front @ [a]) rest in
      let split_sb = split (fun a -> Set`mem (a, t) sb) in
      let split_sa = split (fun a -> Set`mem (t, a) sb) in
      let rest, sa = split_sa [] ls in
      let nu, bs = split_sb [] (List.rev rest) in
      let sb = List.rev bs in
      let un = List.rev nu in
      let sb_un = List.map ((@) sb) (p t lls [] un) in
      List.map ((@) sa) sb_un in
    let step t lls = List.fold_left (combine t) [] lls in
    Set`fold step ts [[]]

  let partition sb cs es =
    let rec f e lls cs front tail =
      match cs, tail with
      | [], [a] -> (front @ [e :: a]) :: lls
      | c::cs', a::rest ->
          let lls' = (front @ ((e :: a) :: rest)) :: lls in
          if Set`mem (e, c) sb || List.exists (fun t -> Set`mem (e, t) sb) a then
            lls'
          else
            if action`is_access e && not (action`is_fn_store e) then
              f e lls' cs' (front @ [a]) rest
            else
              f e lls  cs' (front @ [a]) rest in
    let step lls e =
      List.fold_left (fun lls ls -> f e lls cs [] ls) [] lls in
    List.fold_left step [BatList.make (1 + List.length cs) []] es
(*
  let rec merge d pre perm part =
    match perm, part with
    | [], [ts] -> schedule pre ts
    | c::cs, ts::tss ->
        let combine_pres (c1, ls1) (c2, ls2) = c`union c1 c2, ls1 @ ls2 in
        merge d (schedule (BatList.product_map combine_pres pre c) ts) cs tss
    | _ -> assert (false)
*)

  let rec seq d pre future =
    if Set`is_empty future then
      pre
    else
      let sb, sa = partition_sb d future in
      let sb_calls, sb_rest = Set`partition action`is_call sb in
      let sa_ucalls, sa_rest =
        Set`partition
          (fun a -> action`is_call a
            && Set`exists (fun a' -> not (Set`mem (a',a) d.seq_before)) sb)
          sa in
      let calls = Set`union sb_calls sa_ucalls in
      if Set`is_empty calls then
        seq d (schedule pre sb) sa
      else
        let sb_accesses, sb_other = Set`partition action`is_access sb_rest in
        let pre = schedule pre sb_other in
        let sa_rest_todo, sa_rest_rest = Set`partition
          (fun a -> Set`exists
            (fun c -> Set`mem (a, c) d.seq_before
              || not (Set`mem (c, a) d.seq_before)) calls)
          sa_rest in
        let todo_list =
          let rec f ls t =
            if Set`is_empty t then
              ls
            else
              let sb, sa = Set`partition
                (fun a -> Set`for_all
                  (fun a' -> not (Set`mem (a', a) d.seq_before)) t) t in
              f (Set`elements sb @ ls) sa in
          f [] (Set`union sb_accesses sa_rest_todo) in
        let call_map =
          let seq_call c = seq d [] (M.find c d.fs_actions) in
          Pmap`of_list (List.map (fun c -> c, seq_call c) (Set`elements calls)) in
        let perm = permute d.seq_before calls in
        let rec interleave pre cs ts =
          match cs, ts with
          | [], [t] -> List.map (fun p -> p @ t) pre
          | c::cs', t::ts ->
              let pre = List.map (fun p -> p @ t) pre in
              let pre = BatList.product_map (@) pre (M.find c call_map) in
              interleave pre cs' ts in
        let merge lls cs =
          let part = partition d.seq_before cs todo_list in
          List.fold_left (fun lls ts -> interleave pre cs ts @ lls) lls part in
        seq d (List.fold_left merge [] perm) sa_rest_rest

  let linearise d = seq d [] d.actions

  let simplify d c =
    let module P = c`Process in
    let conflicts =
      Pmap`fold
        (fun ts c -> c`union c (action`conflicts d.seq_before ts))
        d.fs_actions c`empty in
    try
      let p = p`make d.constraints in
      let p = p`union p conflicts in
      let f c trace =
        try
(*
          Set`add (action`memory`replay p trace) c
*)
          (action`memory`replay p trace) :: c
        with
        | p`Partial _ -> assert (false)
        | p`Invalid -> c in
      List.fold_left f c (linearise d)
    with p`Invalid -> c
(*
      List.fold_left f (Set`create c`compare) traces
    with p`Invalid -> Set`create c`compare
*)

  let simplify_all t = Set`of_list (*~cmp:c`compare*) (Set`fold simplify t [])

  let simplify_result = function
    | Ail.Program t -> Ail.Program (simplify_all t)
    | Ail.Invalid -> Ail.Invalid
    | Ail.Undefined -> Ail.Undefined
end

module Graph = struct
  let dot n t =
    Set`fold
      (fun d i ->
        let name = n ^ "." ^ (BatInt.to_string i) ^ ".dot" in
        let doc = action`print`pp_dot d.seq_before in
        let str = Document.to_plain_string doc in
        let () = Output.write str (Output.file name) in
        i + 1
      ) t 0
  let dot_result n = function
    | Ail.Program t -> ignore (dot n t)
    | _ -> ()
end
