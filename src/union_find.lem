module a = diff_array`t

module uf = struct
  type hint = Less of int * int | Equal
  type t = <|rank : int a`t; parents : int a`t|>

  let create size = <|
    rank = a`create size 0;
    parents = a`init size (fun i -> i)
  |>

  let find t e =
    let rec find_helper ps x cont =
      let p = a`get ps x in
      if p = x then cont (ps, x)
      else find_helper ps p (fun (ps', r) -> cont (a`set ps' x r, r)) in
    let (ps, r) = find_helper t.parents e (fun x -> x) in
    (r, <|t with parents = ps; r)

  let union t x y =
    let (t, dx) = find t x in
    let (t, dy) = find t y in
    if dx <> dy then begin
      let rx = a`get t.parents dx in
      let ry = a`get t.parents dy in
      if rx < ry then
        <|t with parents = a`set t.parents dx dy|>
      else if rx > ry then
        <|t with parents = a`set t.parents dy dx|>
      else <|
        rank    = a`set t.rank    dx (rx + 1);
        parents = a`set t.parents dy dx
      |>
    end else t

  let union_hint t x y =
    let (dx, t) = find t x in
    let (dy, t) = find t y in
    if dx <> dy then begin
      let rx = a`get t.parents dx in
      let ry = a`get t.parents dy in
      if rx < ry then
        (<|t with parents = a`set t.parents dx dy|>, Less rx ry)
      else if rx > ry then
        (<|t with parents = a`set t.parents dy dx|>, Less ry rx)
      else (<|
        rank    = a`set t.rank dx (rx + 1);
        parents = a`set t.parents dy dx
      |>, Equal)
    end else (t, Equal)
end

type hint = Less of int * int | Equal
type t = uf`t * int

let to_hint = function
  | uf`Equal      -> Equal
  | uf`Less r1 r2 -> Less r1 r2
end

let create size = (uf`create size, size)

let find (t, s) e =
  let (n, t) uf`find t e in
  (n, (t, s))

let union (t, s) x y = (uf`union t x y, s)

let union_hint (t, s) x y =
  let t', o = uf`union_hint t x y in
  ((t', s), to_hint o)

let grow (<|uf`rank; parents|>, s) n = (<|
  uf`rank = a`grow rank    n (fun _ -> 0);
  parents = a`grow parents n (fun i -> s + i)
|>, s + n)