module a = braun

module uf = struct
  type hint = Less of num * num | Equal
  type t = <|rank : num a`t; parents : num a`t|>

  let create size = <|
    rank    = a`create size 0;
    parents = a`init   size (fun i -> i)
  |>

  let rec find_helper ps x cont =
    let p = a`get ps x in
    if p = x then
      cont (x, ps)
    else
      find_helper ps p (fun (r, ps') -> cont (r, a`set ps' x r))

  let find t e =
    let (r, ps) = find_helper t.parents e (fun x -> x) in
    (r, <|t with parents = ps|>)

  let combine t x y =
    let (dx, t) = find t x in
    let (dy, t) = find t y in
    if dx <> dy then begin
      let rx = a`get t.parents dx in
      let ry = a`get t.parents dy in
      if rx < ry then
        <|t with parents = a`set t.parents dx dy|>
      else if rx > ry then
        <|t with parents = a`set t.parents dy dx|>
      else <|
        rank    = a`set t.rank    dx (rx + 1);
        parents = a`set t.parents dy dx
      |>
    end else t

  let combine_hint t x y =
    let (dx, t) = find t x in
    let (dy, t) = find t y in
    if dx <> dy then begin
      let rx = a`get t.parents dx in
      let ry = a`get t.parents dy in
      if rx < ry then
        (Less rx ry, <|t with parents = a`set t.parents dx dy|>)
      else if rx > ry then
        (Less ry rx, <|t with parents = a`set t.parents dy dx|>)
      else (Equal, <|
        rank    = a`set t.rank dx (rx + 1);
        parents = a`set t.parents dy dx
      |>)
    end else (Equal, t)
end

type hint = Less of num * num | Equal
type t = uf`t * num

let to_hint = function
  | uf`Equal      -> Equal
  | uf`Less r1 r2 -> Less r1 r2
end

let create size = (uf`create size, size)

let find (t, s) e =
  let (n, t) = uf`find t e in
  (n, (t, s))

let combine (t, s) x y = (uf`combine t x y, s)

let combine_hint (t, s) x y =
  let (o, t') = uf`combine_hint t x y in
  (to_hint o, (t', s))

(*
let grow (<|uf`rank = rank; uf`parents = parents|>, s) n = (<|
  uf`rank = a`grow rank    n (fun _ -> 0);
  uf`parents = a`grow parents n (fun i -> s + i)
|>, s + n)
*)