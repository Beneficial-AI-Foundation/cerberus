open meaning`operators
open meaning`statement_operators

module a = ail
module c = constraint
module m = meaning
module t = types

module tc = type_constraint

let undef = c`eq (c`fresh_named "UNDEFINED") c`one

let exp_type    = annotate`exp_type_of
let lvalue_type = annotate`lvalue_type_of

let is_function_id file e =
  match e with
    | a`Exp _ (a`VARIABLE fid)) ->
        map`find fid file.a`fn_map
    | _ -> None
  end

let update_env env ids =
  List`fold_left (fun e id -> Pmap`add id (c`fresh_address ()) e) env ids

let conv t t' (c, m) =
  let (a, constr) = tc`conv t t' c in
  (a, m +& constr)

let conv_int t (c, m) =
  let (a, constr) = tc`conv_int t c in
  (a, m +& constr)

let rec
| reduce_lvalue n b env file exp =
  let f = reduce_exp n b env file in
  let f_lvalue = reduce_lvalue n b env file in
  match annotate`exp_of exp with
    | a`VARIABLE id -> (Pmap`find id env, m`init)
    | a`UNARY a`INDIRECTION e ->
        let t = t`pointer_convert (exp_type e) in
        let (a, m) = f e in
        let null = c`eq a c`null in
        let ill_aligned = c`neg (tc`align (t`base_of_pointer t) a) in
        let c = c`implies (c`disj null ill_aligned) c`undef in
        (a, m +& c)
  end

| reduce_exp n b env file exp =
  let f = reduce_exp n b env file in
  let f_lvalue e =
    let (a, m) = reduce_lvalue n b env file e in
    (a, m -@> action`id a) in
  let lookup_type id = fst (Pmap`find id file.a`id_map) in
  let conv_exp e = conv_int (exp_type exp) (f e) in
  let usual_arithmetic e1 e2 =
    t`usual_arithmetic (exp_type e1) (exp_type e2) in
  let overflow t c = c`implies (c`neg (tc`in_range t c)) c`undef in
  match annotate`exp_of exp with
    | a`VARIABLE id ->
        if t`is_array (lookup_type id) then
          (Pmap`find id env, m`init)
        else
          let (a, m) = f_lvalue exp in
          let v = c`fresh_name () in
          let load = action`load (lvalue_type exp) a v in
          (v, m -@> load)
    | a`CONSTANT (cabs`CONST_INT (i, _)) -> (c`const i, m`init)
    | a`UNARY a`POSTFIX_INCR e ->
        let (a, m) = f_lvalue e in
        let v = c`fresh_name () in
        let incr = c`plus v c`one in
        let (v', m') = conv_int (exp_type e) (incr, m`init) in
        let modify = action`modify (lvalue_type e) a v v' in
        (v, (m -&- m') -@> modify)
    | a`UNARY a`POSTFIX_DECR e ->
        let (a, m) = f_lvalue e in
        let v = c`fresh_name () in
        let decr = c`minus v c`one in
        let (a', m') = conv_int (exp_type e) (decr, m`init) in
        let modify = action`modify (lvalue_type e) a v a' in
        (v, (m -&- m') -@> modify)
    | a`UNARY a`ADDRESS (a`Exp _ a`UNARY a`INDIRECTION e) -> f e
    | a`UNARY a`ADDRESS e -> f_lvalue e
    | a`CAST t e -> conv t (exp_type e) (f e)
    | a`BINARY (cabs`ARITHMETIC cabs`ADD) e1 e2
        if t`is_arithmetic (exp_type e1) && t`is_arithmetic (exp_type e2) then
          let (a1, m1) = conv_exp e1 in
          let (a2, m2) = conv_exp e2 in
          let sum = c`plus a1 a2 in
          if t`is_signed_integer(exp_type exp) then
            let c = overflow (exp_type exp) sum in
            (sum, m1 -&- m2 +& c)
          else
            let (a, m) = conv_int (exp_type exp) (c`plus a1 a2, m`init) in
            (a, m1 -&- m2 -&- m)
        else
          (* Pointer arithmetic. *)
          let (a1, m1) = f e1 in
          let (a2, m2) = f e2 in
          if t`is_pointer (exp_type e1) then
            let size = tc`size (t`base_of_pointer (exp_type e1)) in
            let a = c`offset a1 a2 size in
            (a, (m1 -&- m2) -@> action`same a1 a)
          else
            let size = tc`size (t`base_of_pointer (exp_type e2)) in
            let a = c`offset a2 a1 size in
            (a, (m1 -&- m2) -@> action`same a a1)
    | a`BINARY (cabs`ARITHMETIC cabs`SUB) e1 e2 ->
        if t`is_arithmetic (exp_type e1) && t`is_arithmetic (exp_type e2) then
          let (a1, m1) = conv_exp e1 in
          let (a2, m2) = conv_exp e2 in
          let diff = c`minus a1 a2 in
          if t`is_signed_integer (exp_type exp) then
            let c = overflow (exp_type exp) diff in
            (diff, (m1 -&- m2) +& c)
          else
            let (a, m) = conv_int (exp_type exp) (c`minus a1 a2, m`init) in
            (a, m1 -&- m2 -&- m)
        else (*if t`is_integer (exp_type e2) then*)
          (* Pointer arithmetic. *)
          let (a1, m1) = f e1 in
          let (a2, m2) = f e2 in
          let size = tc`size (t`base_of_pointer (exp_type e1)) in
          let a = c`offset a1 (c`minus c`zero a2) size in
          (a, (m1 -&- m2) -@> action`same a1 a)
    | a`BINARY (cabs`ARITHMETIC cabs`MOD) e1 e2 ->
        let (a1, m1) = conv_exp e1 in
        let (a2, m2) = conv_exp e2 in
        let modulo = c`modulo a1 a2 in
        let div_zero = c`implies (c`eq a2 c`zero) c`undef in
        if t`is_signed_integer(exp_type exp) then
          let c = overflow (exp_type exp) (c`div a1 a2) in
          (modulo, (m1 -&- m2) +& div_zero +& c)
        else
          (a, (m1 -&- m2 -&- m) +& div_zero)      
    | a`BINARY (cabs`SEQUENTIAL cabs`COMMA) e1 e2 ->
        let (_,  m1) = f e1 in
        let (a2, m2) = f e2 in
        (a2, m1 -&> m2)
    | a`BINARY (cabs`SEQUENTIAL cabs`OR) e1 e2 ->
        let (a1, m1) = f e1 in
        let (a2, m2) = f e2 in
        let a = c`fresh_name () in
        let first_only = c`conj (c`neq a1 c`zero) (c`eq a c`one) in
        let both = c`conj
          (c`eq a1 c`zero)
          (c`case (c`eq a2 c`zero) (c`eq a c`zero) (c`eq a c`one)) in
        (a, (m1 +& first_only) -/- ((m1 -&> m2) +& both)
    | a`BINARY (cabs`SEQUENTIAL cabs`AND) e1 e2 ->
        let (a1, m1) = f e1 in
        let (a2, m2) = f e2 in
        let a = c`fresh_name () in
        let first_only = c`conj (c`eq a1 c`zero) (c`eq a c`zero) in
        let both = c`conj
          (c`neq a1 c`zero)
          (c`case (c`neq a2 c`zero) (c`eq a c`one) (c`eq a c`zero)) in
        (a, (m1 +& first_only) -/- ((m1 -&> m2) +& both))
    | a`BINARY (cabs`ARITHMETIC cabs`SHL) e1 e2 ->
        let (a1, m1) = conv_exp e1 in
        let (a2, m2) = conv_int (t`promote (exp_type e1)) (f e2) in
        let shifted = c`mult a1 (c`pow a2) in
        if t`is_signed_integer (exp_type exp) then
          let not_repr = c`neg (tc`in_range (exp_type exp) shifted) in
          let neg = c`lt shifted c`zero in
          let c = c`implies (c`disj neg not_repr) c`undef in
          shifted, (m1 -&- m2) +& c
        else
          let (a, m) = conv_int (exp_type exp) (shifted, m`init) in
          (a, m1 -&- m2 -&- m)
    | a`BINARY (cabs`ARITHMETIC cabs`SHR) e1 e2 ->
        let (a1, m1) = conv_exp e1 in
        let (a2, m2) = conv_int (t`promote (exp_type e1)) (f e2) in
        let shifted = c`div a1 (c`pow a2) in
        if t`is_signed_integer (exp_type exp) then
          let a = c`fresh_name () in
          let negative = c`lt shifted c`zero in
          let c = c`case negative
            (c`eq a (c`fn "shift_r" [shifted]))
            (c`eq a shifted) in
          (shifted, (m1 -&- m2) +& c)
        else
          (shifted, m1 -&- m2)
    | a`BINARY (cabs`RELATIONAL cabs`EQ) e1 e2 ->
        if t`is_arithmetic (exp_type e1) && t`is_arithmetic (exp_type e2) then
          let t = usual_arithmetic e1 e2 in
          let (a1, m1) = conv_int t (f e1) in
          let (a2, m2) = conv_int t (f e2) in
          let a = c`fresh_name () in
          let c = c`case (c`eq a1 a2) (c`eq a c`one) (c`eq a c`zero) in
          (a, (m1 -&- m2) +& c)
        else if t`is_pointer (exp_type e1) && t`is_pointer (exp_type e2) then
        else if typing`is_null_pointer e1 then
        else
    | a`BINARY (cabs`RELATIONAL cabs`NE) e1 e2 ->
        if t`is_real (exp_type e1) then
          let t = usual_arithmetic e1 e2 in
          let (a1, m1) = conv_int t (f e1) in
          let (a2, m2) = conv_int t (f e2) in
          let a = c`fresh_name () in
          let c = c`case (c`neg (c`eq a1 a2))
            (c`eq a c`one)
            (c`eq a c`zero) in
          (a, (m1 -&- m2) +& c)
        else
          (* Pointer comparison. *)
    | a`BINARY (cabs`RELATIONAL cabs`LT) e1 e2
        if t`is_real (exp_type e1) then
          let t = usual_arithmetic e1 e2 in
          let (a1, m1) = conv_int t (f e1) in
          let (a2, m2) = conv_int t (f e2) in
          let a = c`fresh_name () in
          let c = c`case (c`lt a1 a2) (c`eq a c`one) (c`eq a c`zero) in
          (a, (m1 -&- m2) +& c)
        else
          (* Pointer comparison. *)
    | a`BINARY (cabs`RELATIONAL cabs`LE) e1 e2
        if t`is_real (exp_type e1) then
          let t = usual_arithmetic e1 e2 in
          let (a1, m1) = conv_int t (f e1) in
          let (a2, m2) = conv_int t (f e2) in
          let a = c`fresh_name () in
          let c = c`case (c`le a1 a2) (c`eq a c`one) (c`eq a c`zero) in
          (a, (m1 -&- m2) +& c)
        else
          (* Pointer comparison. *)
    | a`BINARY (cabs`RELATIONAL cabs`GT) e1 e2 ->
        if t`is_real (exp_type e1) then
          let t = usual_arithmetic e1 e2 in
          let (a1, m1) = conv_int t (f e1) in
          let (a2, m2) = conv_int t (f e2) in
          let a = c`fresh_name () in
          let c = c`case (c`gt a1 a2) (c`eq a c`one) (c`eq a c`zero) in
          (a, (m1 -&- m2) +& c)
        else
          (* Pointer comparison. *)
          (* TODO Comparing two pointers to different object is
             undefined. Unless ... *)
          let (a1, m1) = f e1 in
          let (a2, m2) = f e2 in
          let a = c`fresh_name () in
          let c = c`case (c`gt a1 a2) (c`eq a c`one) (c`eq a c`zero) in
          (a, (m1 -&- m2) +& c)
    | a`BINARY (cabs`RELATIONAL cabs`GE) e1 e2 ->
        if t`is_arithmetic (exp_type e1) then
          let t = usual_arithmetic e1 e2 in
          let (a1, m1) = conv_int t (f e1) in
          let (a2, m2) = conv_int t (f e2) in
          let a = c`fresh_name () in
          let c = c`case (c`ge a1 a2) (c`eq a c`one) (c`eq a c`zero) in
          (a, (m1 -&- m2) +& c)
        else
          (* Pointer comparison. *)
    | a`BINARY (cabs`ARITHMETIC cabs`BAND) e1 e2 ->
        let (a1, m1) = conv_exp e1 in
        let (a2, m2) = conv_exp e2 in
        let a = c`fresh_name () in
        (a, (m1 -&- m2) +& (c`eq a (c`bit_and a1 a2)))
    | a`BINARY (cabs`ARITHMETIC cabs`BOR) e1 e2 ->
        let (a1, m1) = conv_exp e1 in
        let (a2, m2) = conv_exp e2 in
        let a = c`fresh_name () in
        (a, (m1 -&- m2) +& (c`eq a (c`bit_or a1 a2)))
    | a`BINARY (cabs`ARITHMETIC cabs`XOR) e1 e2 ->
        let (a1, m1) = conv_exp e1 in
        let (a2, m2) = conv_exp e2 in
        let a = c`fresh_name () in
        (a, (m1 -&- m2) +& (c`eq a (c`bit_xor a1 a2)))
    | a`ASSIGN None e1 e2 ->
        let (a1, m1) = f_lvalue e1 in
        let (a2, m2) = f e2 in
        let (a, m) =
          conv (exp_type e1) (exp_type e2) (a2, m`init) in
        let write = action`store (lvalue_type e1) a1 a in
        (a,  (m1 -&- m2 -&- m) -@> write)
    | a`QUESTION e1 e2 e3
        if t`is_arithmetic (exp_type e1) && t`is_arithmetic (exp_type e2) then
          let (a1, m1) = f e1 in
          let (a2, m2) = conv_exp e2 in
          let (a3, m3) = conv_exp e3 in
          let a = c`fresh_name () in
          let pos = m2 +& (c`eq a a2) +& (c`eq  a1 c`zero) in
          let neg = m3 +& (c`eq a a3) +& (c`neq a1 c`zero) in
          (a, m1 -&> (pos -/- neg))
    | a`CALL e es ->
        match is_function_id file e with
          | Some (ids, s) ->
              let depth = Pmap`find fid b in
              if depth = 0 then
                (c`fresh_name (), m`none)
              else
                let b' = Pmap`add fid (depth - 1) b in
                let env' = update_env env ids in
                let ids_t = [(Pmap`find id env', lookup_type id) | forall (id IN ids) | true] in
                let m_args = List`fold_left2
                  (fun m' (l, t) e ->
                    let (a, m) = conv (t`unqualify t) (exp_type e) (f e) in
                    let create = action`create   t l   in
                    let store  = action`fn_store t l a in
                    (m' -&- m) +@ create -@> store
                  ) m`init ids_t es in
                let kill_ids m (l, _) = m +@ action`kill l in
                let kill_ids = {l | forall ((l, _) MEM ids_t) | true} in
                let kills = Set`fold (fun s id -> action`kill s id)
                let m_kill = List`fold_left kill_ids m`init ids_t in
                let m_kill = m`add_actions m acts in
                let a = c`fresh_name () in
                let m_body = m`flatten_func (reduce_stmt n b' env' file s fid a) in
                (a, m_args -&> m_body -&> m_kill)      
        end
  end

| reduce_stmt n b env file (a`Stmt _ stmt) fid return =
  let f_s = reduce_stmt n b env file fid return in
  let f_e = reduce_exp  n b env file in
  let lift (a, m) = (a, m`normal m) in
  let lookup_type id = fst (Pmap`find id file.a`id_map) in
  match stmt with
    | a`SKIP -> m`init_func
    | a`IF e s1 s2 ->
        let (a, m) = lift (f_e e) in
        let pos = f_s s1 ++& (c`neq a c`zero) in
        let neg = f_s s2 ++& (c`eq  a c`zero) in
        m --&> (pos -//- neg)
    | a`BLOCK ids ss ->
        let module S = BatSet in
        let create_ids m (l, t) = m ++@ action`create t l in
        let kill_ids   m (l, _) = m union {action`kill l} in
        let env' = update_env env ids in
        let ids_t = List`map (fun i -> Pmap`find i env', lookup_type i) ids in
        let m_create = List`fold_left create_ids m`init_func ids_t in
        let m_kill   = List`fold_left kill_ids empty ids_t in
        let m =
          List`fold_left
            (fun m s -> m --&> (reduce_stmt n b env' file s fid return))
            m`init_func ss in
        m`add_actions_entire_func_sb (m_create --&> m) m_kill
    | a`DECLARATION defns ->
        let define (id, e) =
          let t = lookup_type id in
          let (a, m) = lift (conv t (exp_type e) (f_e e)) in
          m --@> action`store t (Pmap`find id env) a in
        List`fold_left (fun m p -> m --&> define p) m`init_func defns
    | a`RETURN_EXPRESSION e ->
        let t_return =
          match lookup_type fid with
            | a`FUNCTION t _ -> t
            | _ -> invalid_arg "Not a function type."
          end in
        let (a, m) = conv t_return (exp_type e) (f_e e) in
        m`return (m`add_constraint m (c`eq a return))
    | a`RETURN_VOID -> m`return m`init
    | a`EXPRESSION e -> snd (lift (f_e e))
    | a`WHILE e s ->
        let m_neg (a, m) = m +& (c`eq  a c`zero) in
        let m_pos (a, m) = m +& (c`neq a c`zero) in
        let rec iterate m = function
          | 0 -> m`exit_loop (m_neg (f_e e)) m
          | n ->
              let test = f_e e in
              let m' = m`enter_loop (m_pos test) (m_neg test) m in
              iterate (m' --&> f_s s) (n-1)
        end in
        iterate m`init_func n
    | a`BREAK    -> m`break    m`init
    | a`CONTINUE -> m`continue m`init
  end

let reduce_file n file =
  let b =
    List`fold_left (fun m fid -> Pmap`add fid n m) Pmap`empty (Pmap`keys file.a`fn_map) in
  let (_, s) = Pmap`find file.a`main file.a`fn_map in
  let m = reduce_stmt n b Pmap`empty file s main (c`fresh_named "return") in
  m`flatten_func m
(*
  List`map rd (List`map snd (Pmap`values file.a`fn_map))
*)

module print = struct
  let pp = ()
end
