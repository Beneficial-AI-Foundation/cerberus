open meaning`operators
open meaning`statement_operators

module a = ail
module c = constraint
module m = meaning
module t = types

module tc = type_constraint

let undef = c`eq (c`fresh_named "UNDEFINED") c`one

let exp_type    = annotate`exp_type_of
let lvalue_type = annotate`lvalue_type_of

let is_function_id file e =
  match e with
    | a`Exp _ (a`VARIABLE fid)) ->
        map`find fid file.a`fn_map
    | _ -> None
  end

let update_env env ids =
  List`fold_left (fun e id -> Pmap`add id (c`fresh_address ()) e) env ids

let conv t t' (c, m) =
  let (a, constr) = tc`conv t t' c in
  (a, m +& constr)

let conv_int t (c, m) =
  let (a, constr) = tc`conv_int t c in
  (a, m +& constr)

let rec iterate f_s f _e n ml e s =
  let m_neg (a, m) = m +& (c`eq  a c`zero) in
  let m_pos (a, m) = m +& (c`neq a c`zero) in
  f_e e >>= fun m   ->
  f_s s >>= fun ml' ->
  match n with
  | 0 -> unit (m`exit_loop (m_neg m) ml)
  | _ -> iterate (m`enter_loop (m_pos m) (m_neg m) ml --&> ml') (n-1)
end

let rec
| reduce_lvalue n b env file exp =
  let f = reduce_exp n b env file in
  let f_lvalue = reduce_lvalue n b env file in
  match annotate`exp_of exp with
  | a`VARIABLE id ->
      unit (Pmap`find id env, m`init)
  | a`UNARY a`INDIRECTION e ->
      f e >>= fun (a, m) ->
      let t = t`base_of_pointer (t`pointer_convert (exp_type e)) in
      let ill_aligned = c`neg (tc`align t a) in
      let null = c`eq a c`null in
      let c = c`implies (c`disj null ill_aligned) c`undef in
      unit (a, m +& c)
  end

| reduce_exp n b env file exp =
  let f = reduce_exp n b env file in
  let f_lvalue e =
    let (a, m) = reduce_lvalue n b env file e in
    (a, m -@> action`id a) in
  let lookup_type id = fst (Pmap`find id file.a`id_map) in
  let conv_exp e = f e >>= conv_int (exp_type exp) in
  let usual_arithmetic e1 e2 =
    t`usual_arithmetic (exp_type e1) (exp_type e2) in
  let overflow t c = c`implies (c`neg (tc`in_range t c)) c`undef in
  match annotate`exp_of exp with
  | a`VARIABLE id ->
      if t`is_array (lookup_type id) then
        (Pmap`find id env, m`init)
      else
        f_lvalue exp >>= fun (a, m) ->
        c`fresh >>= fun v      ->
        let load = action`load (lvalue_type exp) a v in
        unit (v, m -@> load)
  | a`CONSTANT (cabs`CONST_INT (i, _)) -> (c`const i, m`init)
  | a`UNARY a`POSTFIX_INCR e ->
      f_lvalue e >>= fun (a, m) ->
      c`fresh    >>= fun v      ->
      let incr = c`plus v c`one in
      conv_int (exp_type e) (incr, m`init) >>= fun (v', m') ->
      let modify = action`modify (lvalue_type e) a v v' in
      unit (v, (m -&- m') -@> modify)
  | a`UNARY a`POSTFIX_DECR e ->
      f_lvalue e >>= fun (a, m) ->
      c`fresh    >>= fun v      ->
      let decr = c`minus v c`one in
      conv_int (exp_type e) (decr, m`init) >>= fun (a', m') ->
      let modify = action`modify (lvalue_type e) a v a' in
      unit (v, (m -&- m') -@> modify)
  | a`UNARY a`ADDRESS (a`Exp _ a`UNARY a`INDIRECTION e) -> f e
  | a`UNARY a`ADDRESS e -> f_lvalue e
  | a`CAST t e -> conv t (exp_type e) (f e)
  | a`BINARY (cabs`ARITHMETIC cabs`ADD) e1 e2 ->
      if t`is_arithmetic (exp_type e1) && t`is_arithmetic (exp_type e2) then
        conv_exp e1 >>= fun (a1, m1) ->
        conv_exp e2 >>= fun (a2, m2) ->
        let sum = c`plus a1 a2 in
        if t`is_signed_integer(exp_type exp) then
          let c = overflow (exp_type exp) sum in
          unit (sum, m1 -&- m2 +& c)
        else
          let (a, m) = conv_int (exp_type exp) (c`plus a1 a2, m`init) in
          unit (a, m1 -&- m2 -&- m)
      else
        (* Pointer arithmetic. *)
        f e1 >>= fun (a1, m1) ->
        f e2 >>= fun (a2, m2) ->
        if t`is_pointer (exp_type e1) then
          let size = tc`size (t`base_of_pointer (exp_type e1)) in
          let a = c`offset a1 a2 size in
          unit (a, (m1 -&- m2) -@> action`same a1 a)
        else
          let size = tc`size (t`base_of_pointer (exp_type e2)) in
          let a = c`offset a2 a1 size in
          unit (a, (m1 -&- m2) -@> action`same a a1)
  | a`BINARY (cabs`ARITHMETIC cabs`SUB) e1 e2 ->
      if t`is_arithmetic (exp_type e1) && t`is_arithmetic (exp_type e2) then
        conv_exp e1 >>= fun (a1, m1) ->
        conv_exp e2 >>= fun (a2, m2) ->
        let diff = c`minus a1 a2 in
        if t`is_signed_integer (exp_type exp) then
          let c = overflow (exp_type exp) diff in
          unit (diff, (m1 -&- m2) +& c)
        else
          let (a, m) = conv_int (exp_type exp) (c`minus a1 a2, m`init) in
          unit (a, m1 -&- m2 -&- m)
      else (*if t`is_integer (exp_type e2) then*)
        (* Pointer arithmetic. *)
        f e1 >>= fun (a1, m1) ->
        f e2 >>= fun (a2, m2) ->
        let size = tc`size (t`base_of_pointer (exp_type e1)) in
        let a = c`offset a1 (c`minus c`zero a2) size in
        unit (a, (m1 -&- m2) -@> action`same a1 a)
  | a`BINARY (cabs`ARITHMETIC cabs`MOD) e1 e2 ->
      conv_exp e1 >>= fun (a1, m1) ->
      conv_exp e2 >>= fun (a2, m2) ->
      let modulo = c`modulo a1 a2 in
      let div_zero = c`implies (c`eq a2 c`zero) c`undef in
      if t`is_signed_integer(exp_type exp) then
        let c = overflow (exp_type exp) (c`div a1 a2) in
        unit (modulo, (m1 -&- m2) +& div_zero +& c)
      else
        unit (a, (m1 -&- m2 -&- m) +& div_zero)
  | a`BINARY (cabs`SEQUENTIAL cabs`COMMA) e1 e2 ->
      f e1 >>= fun (_,  m1) ->
      f e2 >>= fun (a2, m2) ->
      unit (a2, m1 -&> m2)
  | a`BINARY (cabs`SEQUENTIAL cabs`OR) e1 e2 ->
      f e1    >>= fun (a1, m1) ->
      f e2    >>= fun (a2, m2) ->
      c`fresh >>= fun a        ->
      let first_only = c`conj (c`neq a1 c`zero) (c`eq a c`one) in
      let both = c`conj
        (c`eq a1 c`zero)
        (c`case (c`eq a2 c`zero) (c`eq a c`zero) (c`eq a c`one)) in
      unit (a, (m1 +& first_only) -/- ((m1 -&> m2) +& both)
  | a`BINARY (cabs`SEQUENTIAL cabs`AND) e1 e2 ->
      f e1    >>= fun (a1, m1) ->
      f e2    >>= fun (a2, m2) ->
      c`fresh >>= fun a        ->
      let first_only = c`conj (c`eq a1 c`zero) (c`eq a c`zero) in
      let both = c`conj
        (c`neq a1 c`zero)
        (c`case (c`neq a2 c`zero) (c`eq a c`one) (c`eq a c`zero)) in
      unit (a, (m1 +& first_only) -/- ((m1 -&> m2) +& both))
  | a`BINARY (cabs`ARITHMETIC cabs`SHL) e1 e2 ->
      conv_exp e1 >>= fun (a1, m1) ->
      conv_int (t`promote (exp_type e1)) (f e2) >>= fun (a2, m2) ->
      let shifted = c`mult a1 (c`pow a2) in
      if t`is_signed_integer (exp_type exp) then
        let not_repr = c`neg (tc`in_range (exp_type exp) shifted) in
        let neg = c`lt shifted c`zero in
        let c = c`implies (c`disj neg not_repr) c`undef in
        unit (shifted, (m1 -&- m2) +& c)
      else
        conv_int (exp_type exp) (shifted, m`init) >>= fun (a, m) ->
        unit (a, m1 -&- m2 -&- m)
  | a`BINARY (cabs`ARITHMETIC cabs`SHR) e1 e2 ->
      conv_exp e1 >>= fun (a1, m1) ->
      conv_int (t`promote (exp_type e1)) (f e2) >>= fun (a2, m2) ->
      let shifted = c`div a1 (c`pow a2) in
      if t`is_signed_integer (exp_type exp) then
        c`fresh >>= fun a ->
        let negative = c`lt shifted c`zero in
        let c = c`case negative
          (c`eq a (c`fn "shift_r" [shifted]))
          (c`eq a shifted) in
        unit (shifted, (m1 -&- m2) +& c)
      else
        unit (shifted, m1 -&- m2)
  | a`BINARY (cabs`RELATIONAL cabs`EQ) e1 e2 ->
      if t`is_arithmetic (exp_type e1) && t`is_arithmetic (exp_type e2) then
        let t = usual_arithmetic e1 e2 in
        conv_int t (f e1) >>= fun (a1, m1) ->
        conv_int t (f e2) >>= fun (a2, m2) ->
        c`fresh           >>= fun a        ->
        let c = c`case (c`eq a1 a2) (c`eq a c`one) (c`eq a c`zero) in
        unit (a, (m1 -&- m2) +& c)
      else if t`is_pointer (exp_type e1) && t`is_pointer (exp_type e2) then
      else if typing`is_null_pointer e1 then
      else
  | a`BINARY (cabs`RELATIONAL cabs`NE) e1 e2 ->
      if t`is_real (exp_type e1) then
        let t = usual_arithmetic e1 e2 in
        conv_int t (f e1) >>= fun (a1, m1) ->
        conv_int t (f e2) >>= fun (a2, m2) ->
        c`fresh           >>= fun a        ->
        let c = c`case (c`neg (c`eq a1 a2)) (c`eq a c`one) (c`eq a c`zero) in
        unit (a, (m1 -&- m2) +& c)
      else
        (* Pointer comparison. *)
  | a`BINARY (cabs`RELATIONAL cabs`LT) e1 e2
      if t`is_real (exp_type e1) then
        let t = usual_arithmetic e1 e2 in
        conv_int t (f e1) >>= fun (a1, m1) ->
        conv_int t (f e2) >>= fun (a2, m2) ->
        c`fresh >>= fun a ->
        let c = c`case (c`lt a1 a2) (c`eq a c`one) (c`eq a c`zero) in
        unit (a, (m1 -&- m2) +& c)
      else
        (* Pointer comparison. *)
  | a`BINARY (cabs`RELATIONAL cabs`LE) e1 e2
      if t`is_real (exp_type e1) then
        let t = usual_arithmetic e1 e2 in
        conv_int t (f e1) >>= fun (a1, m1) ->
        conv_int t (f e2) >>= fun (a2, m2) ->
        c`fresh       	  >>= fun a        ->
        let c = c`case (c`le a1 a2) (c`eq a c`one) (c`eq a c`zero) in
        unit (a, (m1 -&- m2) +& c)
      else
        (* Pointer comparison. *)
  | a`BINARY (cabs`RELATIONAL cabs`GT) e1 e2 ->
      if t`is_real (exp_type e1) then
        let t = usual_arithmetic e1 e2 in
        conv_int t (f e1) >>= fun (a1, m1) ->
        conv_int t (f e2) >>= fun (a2, m2) ->
        c`fresh           >>= fun a        ->
        let c = c`case (c`gt a1 a2) (c`eq a c`one) (c`eq a c`zero) in
        unit (a, (m1 -&- m2) +& c)
      else
        (* Pointer comparison. *)
        (* TODO Comparing two pointers to different object is
           undefined. Unless ... *)
        f e1	>>= fun (a1, m1) ->
        f e2	>>= fun (a2, m2) ->
        c`fresh >>= fun a        ->
        let c = c`case (c`gt a1 a2) (c`eq a c`one) (c`eq a c`zero) in
        unit (a, (m1 -&- m2) +& c)
  | a`BINARY (cabs`RELATIONAL cabs`GE) e1 e2 ->
      if t`is_arithmetic (exp_type e1) then
        let t = usual_arithmetic e1 e2 in
        conv_int t (f e1) >>= fun (a1, m1) ->
        conv_int t (f e2) >>= fun (a2, m2) ->
        c`fresh           >>= fun a        ->
        let c = c`case (c`ge a1 a2) (c`eq a c`one) (c`eq a c`zero) in
        unit (a, (m1 -&- m2) +& c)
      else
        (* Pointer comparison. *)
  | a`BINARY (cabs`ARITHMETIC cabs`BAND) e1 e2 ->
      conv_exp e1 >>= fun (a1, m1) ->
      conv_exp e2 >>= fun (a2, m2) ->
      c`fresh     >>= fun a        ->
      unit (a, (m1 -&- m2) +& (c`eq a (c`bit_and a1 a2)))
  | a`BINARY (cabs`ARITHMETIC cabs`BOR) e1 e2 ->
      conv_exp e1 >>= fun (a1, m1) ->
      conv_exp e2 >>= fun (a2, m2) ->
      c`fresh     >>= fun a        ->
      unit (a, (m1 -&- m2) +& (c`eq a (c`bit_or a1 a2)))
  | a`BINARY (cabs`ARITHMETIC cabs`XOR) e1 e2 ->
      conv_exp e1 >>= fun (a1, m1) ->
      conv_exp e2 >>= fun (a2, m2) ->
      c`fresh     >>= fun a        ->
      unit (a, (m1 -&- m2) +& (c`eq a (c`bit_xor a1 a2)))
  | a`ASSIGN None e1 e2 ->
      f_lvalue e1 >>= fun (a1, m1) ->
      f e2        >>= fun (a2, m2) ->
      conv (exp_type e1) (exp_type e2) (a2, m`init) >>= fun (a, m) ->
      let write = action`store (lvalue_type e1) a1 a in
      unit (a, (m1 -&- m2 -&- m) -@> write)
  | a`QUESTION e1 e2 e3
      if t`is_arithmetic (exp_type e1) && t`is_arithmetic (exp_type e2) then
        f e1        >>= fun (a1, m1) ->
        conv_exp e2 >>= fun (a2, m2) ->
        conv_exp e3 >>= fun (a3, m3) ->
        c`fresh     >>= fun a        ->
        let pos = m2 +& (c`eq a a2) +& (c`eq  a1 c`zero) in
        let neg = m3 +& (c`eq a a3) +& (c`neq a1 c`zero) in
        unit (a, m1 -&> (pos -/- neg))
  | a`CALL e es ->
      match is_function_id file e with
      | Some (ids, s) ->
          let depth = Pmap`find fid b in
          if depth = 0 then
            c`fresh >>= fun a ->
            unit (a, m`none)
          else
            let b' =  Pmap`add fid (depth - 1) b in
            let env' = update_env env ids in
            let ids_t = [(Pmap`find id env', lookup_type id) | forall (id IN ids) | true] in
            let m_args = List`fold_left2
              (fun m' (l, t) e ->
                let (a, m) = conv (t`unqualify t) (exp_type e) (f e) in
                let create = action`create   t l   in
                let store  = action`fn_store t l a in
                (m' -&- m) +@ create -@> store
              ) m`init ids_t es in
            let kill_ids m (l, _) = m +@ action`kill l in
            let kill_ids = {l | forall ((l, _) MEM ids_t) | true} in
            let kills = Set`fold (fun s id -> action`kill s id)
            let m_kill = List`fold_left kill_ids m`init ids_t in
            let m_kill = m`add_actions m acts in
            c`fresh >>= fun a ->
	    reduce_stmt n b' env' file s fid a >>= fun ml_body ->
            unit (a, m_args -&> m`flatten ml_body -&> m_kill)
      end
  end

| reduce_stmt n b env file (a`Stmt _ stmt) fid return =
  let f_s = reduce_stmt n b env file fid return in
  let f_e = reduce_exp  n b env file in
  let lift x = x >>= fun (a, m) -> (a, m`normal m) in
  let lookup_type id = fst (Pmap`find id file.a`id_map) in
  match stmt with
  | a`SKIP ->
      unit m`init_lifted
  | a`IF e s1 s2 ->
      lift (f_e e) >>= fun (a, ml) ->
      f_s s1       >>= fun ml1     ->
      f_s s2       >>= fun ml2     ->
      let pos = ml1 ++& (c`neq a c`zero) in
      let neg = ml2 ++& (c`eq  a c`zero) in
      unit (ml --&> (pos -//- neg))
  | a`BLOCK ids ss ->
      let create_ids ml (l, t) = ml ++@ action`create t l in
      let kill_ids   ml (l, _) = ml union {action`kill l} in
      let env' = update_env env ids in
      let ids_t = List`map (fun i -> Pmap`find i env', lookup_type i) ids in
      let ml_create = List`fold_left create_ids m`init_lifted ids_t in
      let ml_kill   = List`fold_left kill_ids empty ids_t in
      let ml =
        fold_list
          (fun ml s -> ml --&> (reduce_stmt n b env' file s fid return))
          m`init_lifted ss in
      (ml_create --&> ml) --@> ml_kill
  | a`DECLARATION defns ->
      let define (id, e) =
        let t = lookup_type id in
        lift (conv t (exp_type e) (f_e e)) >>= fun (a, ml) ->
        unit (ml --@> action`store t (Pmap`find id env) a) in
      fold_list (fun ml p -> ml --&> define p) m`init_lifted defns
  | a`RETURN_EXPRESSION e ->
      let t_return =
        match lookup_type fid with
        | a`FUNCTION t _ -> t
        end in
      conv t_return (exp_type e) (f_e e) >>= fun (a, m) ->
      unit (m`return (m +& c`eq a return))
  | a`RETURN_VOID -> unit (m`return m`init)
  | a`EXPRESSION e ->
      lift (f_e e) >>= fun (_, ml) ->
      unit ml
  | a`WHILE e s -> iterate f_s f_e n m`init_lifted e s
  | a`BREAK    -> unit (m`break    m`init)
  | a`CONTINUE -> unit (m`continue m`init)
  end

let reduce_file n file =
  let b =
    List`fold_left (fun m fid -> Pmap`add fid n m) Pmap`empty (Pmap`keys file.a`fn_map) in
  let (_, s) = Pmap`find file.a`main file.a`fn_map in
  let m = reduce_stmt n b Pmap`empty file s main (c`fresh_named "return") in
  m`flatten_lifted m
(*
  List`map rd (List`map snd (Pmap`values file.a`fn_map))
*)

module print = struct
  let pp = ()
end
