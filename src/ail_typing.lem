open global
open exception`operators

module a = ail
module c = cabs

module t = ail_types
module aa = ail_annotate

let report msg exp = ""
let invalid msg exp = exception`fail (report msg exp)

let lvalue_convert t e =
  match t`lvalue_convert t with
    | None ->
        let msg = "Undefined behaviour according to 6.3.2.1#2 Lvalues, arrays, and \
                   function designators: ``If the value has an incomplete \
                   type and does not have array type, the behaviour is undefined. \
                   [...]`` in" in
        exception`fail (report msg e)
    | Some t' -> exception`unit t'
  end

let int = a`BASE empty (a`INTEGER (a`SIGNED a`INT))
let one l = a`Exp l (a`CONSTANT (c`CONST_INT (1, None)))

let rec is_null_pointer (a`Exp _ e) =
  match e with
    | a`CONSTANT (c`CONST_INT (n, _)) -> n = 0
    | a`CAST (a`POINTER _ (a`BASE _ a`VOID)) exp -> is_null_pointer exp
    | _ -> false
  end

(* TODO Could improve specificity of error messages: Currently, we stop as soon
   as a constraint is violated but do not check whether it is partially
   satisfied. *)

(* Implementation note: [check_exp] returns the type of a given expression but
   we (eventually) want to annotate each expression in the abstract syntax tree
   with a type. To avoid redundant type computation, we use open
   recursion. [annotate_exp] complements the process. *)

let rec
| check_exp env l e_head =
  let invalid_head msg = invalid msg (l, e_head) in
  let f e =
    let t =
      match aa`type_of e with
        | a`T_EXP    t -> exception`unit t
        | a`T_LVALUE t -> lvalue_convert t e
      end in
    exception`map t`pointer_convert t in
  let f_lvalue msg e =
    match aa`type_of e with
      | a`T_EXP    _ -> invalid msg e
      | a`T_LVALUE t -> exception`unit (t`pointer_convert t)
    end in
  match e_head with
    | a`VARIABLE id ->
        let (t, _) = Pmap`find id env.a`id_map in
        if Pmap`mem id env.a`fn_map then
          exception`unit (a`T_EXP t)
        else
          exception`unit (a`T_LVALUE t)
    | a`CONSTANT (c`CONST_INT (i, None)) ->
        exception`unit (a`T_EXP (a`BASE empty (a`INTEGER (a`SIGNED a`INT))))
    | a`CONSTANT (c`CONST_INT (_, Some _)) ->
        exception`fail "Suffixes in integer constant expressions are not supported."
    | a`CALL e es ->
        let msg_r = "Violation of constraint 6.5.2.2#1 Function calls, \
                     Constraints: ``The expression that denotes the function \
                     shall have type pointer to function returning void or \
                     returning a complete object type other than an array \
                     type.`` (The return type doesn't seem to be valid.) in" in
        let msg_arg = "Violation of constraint 6.5.2.2#1 Function calls, \
                       Constraints: ``Each argument shall have a type such that \
                       its value may be assigned to an object [...] of the type \
                       corresponding to its parameter.`` in" in
        let msg_l = "Violation of constraint 6.5.2.2#1 Function calls, \
                     Constraints: ``[T]he number of arguments shall agree with \
                     the number of parameters.`` in" in
        let msg_f = "Violation of constraint 6.5.2.2#1 Function calls, \
                     Constraints: ``The expression that denotes the function \
                     shall have type pointer to function [...].`` in" in
        f e >>= (fun t ->
        if t`is_pointer_to_function t then
          let t_f = t`base_of_pointer t in
          let t_r = t`function_return t_f in
          let t_p = t`function_parameters t_f in
          if t`is_void t_r
            || (t`is_complete_object t_r && not (t`is_array t_r)) then
            if List`length t_p = List`length es then
              let test t e =
                (* TODO Hack! *)
                let exp = a`ASSIGN None (one (aa`a_type l (a`T_LVALUE t))) e in
                exception`to_bool (check_exp env l exp) in
              if List`for_all2 test t_p es then
                exception`unit (a`T_EXP t_r)
              else invalid_head msg_arg
            else invalid_head msg_l
          else invalid msg_r e
        else invalid msg_f e)
    | a`UNARY a`POSTFIX_INCR e ->
        let msg_l = "Violation of constraint 6.5.2.4#1 Postfix increment and \
                     decrement operators, Constraints: ``The operand of the \
                     postfix [...] decrement operator [...] shall be a \
                     modifiable lvalue.`` in" in
        let msg_r = "Violation of constraint 6.5.2.4#1 Postfix increment and \
                     decrement operators, Constraints: ``The operand of the \
                     postfix [...] decrement operator [...] shall have [...] \
                     real or pointer type [...].`` in" in
        f_lvalue msg_l e >>= (fun t ->
        if t`is_modifiable t then
          if t`is_real t || t`is_pointer t then
	    annotate_exp env (one l) >>= (fun a_one ->
            check_exp env l (a`ASSIGN (Some c`ADD) e a_one))
          else invalid msg_r e
        else invalid msg_l e)
    | a`UNARY a`POSTFIX_DECR e ->
        let msg_l = "Violation of constraint 6.5.2.4#1 Postfix increment and \
                     decrement operators, Constraints: ``The operand of the \
                     postfix increment [...] operator [...] shall be a \
                     modifiable lvalue.`` in" in
        let msg_r = "Violation of constraint 6.5.2.4#1 Postfix increment and \
                     decrement operators, Constraints: ``The operand of the \
                     postfix increment [...] operator [...] shall have [...] \
                     real or pointer type [...].`` in" in
        f_lvalue msg_l e >>= (fun t ->
        if t`is_modifiable t then
          if t`is_real t || t`is_pointer t then
            annotate_exp env (one l) >>= (fun a_one ->
            check_exp env l (a`ASSIGN (Some c`SUB) e a_one))
          else invalid msg_r e
        else invalid msg_l e)
    | a`UNARY a`ADDRESS e ->
        let msg_f = "Violation of constraint 6.5.3.2#1 Address and indirection \
                     operators, Constraints: ``The operand of the & operator \
                     shall be either a function designator [...] or an lvalue \
                     that designates an object [...].`` in" in
        match aa`type_of e with
          | a`T_EXP ((a`FUNCTION _ _) as t) -> exception`unit t
          | a`T_EXP _ -> invalid msg_f e
          | a`T_LVALUE t ->
              if t`is_object t then
                exception`unit t
              else
                invalid msg_f e
        end >>= (fun t ->
        exception`unit (a`T_EXP (a`POINTER empty t)))
    | a`UNARY a`INDIRECTION e ->
        let msg_p = "Violation of constraint 6.5.3.2#2 Address and indirection \
                     operators, Constraints: ``The operand of the unary * \
                     operator shall have pointer type.`` in" in
        f e >>= (fun t ->
        if t`is_pointer t then
          if t`is_pointer_to_object t then
            exception`unit (a`T_LVALUE (t`base_of_pointer t))
          else exception`unit (a`T_EXP (t`base_of_pointer t))
        else invalid_head msg_p)
    | a`UNARY a`MINUS e ->
        let msg = "Violation of constraint 6.5.3.3#1 Unary arithmetic operators, \
                   Constraints: ``The operand of the unary [...] - operator \
                   shall have arithmetic type [...].`` in" in
        f e >>= (fun t ->
        if t`is_arithmetic t then
          exception`unit (a`T_EXP (t`promote t))
        else invalid msg e)
    | a`UNARY a`PLUS e ->
        let msg = "Violation of constraint 6.5.3.3#1 Unary arithmetic operators, \
                   Constraints: ``The operand of the unary + [...] operator \
                   shall have arithmetic type [...].`` in" in
        f e >>= (fun t ->
        if t`is_arithmetic t then
          exception`unit (a`T_EXP (t`promote t))
        else invalid msg e)
    | a`UNARY a`BNOT e ->
        let msg = "Violation of constraint 6.5.3.3#1 Unary arithmetic operators, \
                   Constraints: ``The operand [...] of the ~ operator [shall \
                   have] integer type [...].`` in" in
        f e >>= (fun t ->
        if t`is_integer t then
          exception`unit (a`T_EXP (t`promote t))
        else invalid msg e)
    | a`SIZEOF t ->
        let msg_i = "Violation of constraint 6.5.3.4#1 The sizeof and alignof \
                     operators, Constraints: ``The sizeof operator shall not be \
                     applied to an [...] incomplete type[...].`` in" in
        let msg_f = "Violation of constraint 6.5.3.4#1 The sizeof and alignof \
                     operators, Constraints: ``The sizeof operator shall not be \
                     applied to [a] [...] function type [...].`` in" in
        if not (t`is_function t) then    
          if not (t`is_incomplete t) then
            exception`unit (a`T_EXP (a`BASE empty (a`INTEGER (a`SIGNED a`INT))))
          else invalid_head msg_i
        else invalid_head msg_f
    | a`ALIGNOF t ->
        let msg_i = "Violation of constraint 6.5.3.4#1 The sizeof and alignof \
                     operators, Constraints: ``The alignof operator shall not be \
                     applied to [...] an incomplete type.`` in" in
        let msg_f = "Violation of constraint 6.5.3.4#1 The sizeof and alignof \
                     operators, Constraints: ``The alignof operator shall not be \
                     applied to a function type [...].`` in" in
        if not (t`is_function t) then    
          if not (t`is_incomplete t) then
            exception`unit (a`T_EXP (a`BASE empty (a`INTEGER (a`SIGNED a`INT))))
          else invalid_head msg_i
        else invalid_head msg_f
    | a`CAST (a`BASE q a`VOID) e ->
        f e >>= (fun _ ->
        exception`unit (a`T_EXP (a`BASE q a`VOID)))
    | a`CAST t' e ->
        let msg_n = "Violation of constraint 6.5.4#1 Cast operators, \
                     Constraints: ``[T]he type name shall specify [...] \
                     scalar type [...].`` in" in
        let msg_s = "Violation of constraint 6.5.4#1 Cast operators, \
                     Constraints: ``[T]he operand shall have scalar type.`` \
                     in" in
        f e >>= (fun t ->
        if t`is_scalar t' then
          if t`is_scalar t then
            exception`unit (a`T_EXP t')
          else invalid msg_s e
        else invalid_head msg_n)
    | a`BINARY (c`ARITHMETIC c`MUL) e1 e2 ->
        check_exp env l (a`BINARY (c`ARITHMETIC c`DIV) e1 e2)
    | a`BINARY (c`ARITHMETIC c`DIV) e1 e2 ->
        let msg = "Violation of constraint 6.5.5#2 Multiplicative operators, \
                   Contraints: ``Each operand shall have arithmetic type.`` \
                   in" in
        f e1 >>= (fun t1 ->
        f e2 >>= (fun t2 ->
        if t`is_arithmetic t1 then
          if t`is_arithmetic t2 then
            exception`unit (a`T_EXP (t`usual_arithmetic t1 t2))
          else invalid msg e2
        else invalid_head msg))
    | a`BINARY (c`ARITHMETIC c`MOD) e1 e2 ->
        let msg = "Violation of constraint 6.5.5#2 Multiplicative operators, \
                   Contraints: ``The operands of the % operator shall have \
                   integer type.`` in" in
        f e1 >>= (fun t1 ->
        f e2 >>= (fun t2 ->
        if t`is_integer t1 then
          if t`is_integer t2 then
            exception`unit (a`T_EXP (t`usual_arithmetic t1 t2))
          else invalid msg e2
        else invalid_head msg))
    | a`BINARY (c`ARITHMETIC c`ADD) e1 e2 ->
        let msg_a = "Violation of constraint 6.5.6#2 Additive operators, \
                     Constraints: ``[B]oth operands shall have arithmetic type \
                     [...].`` in" in
        let msg_i = "Violation of constraint 6.5.6#2 Additive operators, \
                     Constraints: ``[O]ne operand shall be a pointer to a \
                     complete object type and the other shall have integer \
                     type.`` (We were expecting an integer type.) in" in
        let msg_n = "Violation of constraint 6.5.6#2 Additive operators, \
                     Constraints: ``[E] both operands shall have arithmetic \
                     type, or one operand shall be a pointer to a complete \
                     object type and the other shall have integer type.`` in" in
        f e1 >>= (fun t1 ->
        f e2 >>= (fun t2 ->
        (* Case: ptr + int. *)
        if t`is_pointer_to_complete_object t1 then
          if t`is_integer t2 then
            exception`unit (a`T_EXP t1)
          else invalid msg_i e2
        (* Case: int + ptr. *)
        else if t`is_pointer_to_object t2 then
          if t`is_integer t1 then
            exception`unit (a`T_EXP t2)
          else invalid msg_i e1
        (* Case: arith + arith. *)
        else if t`is_arithmetic t1 then
          if t`is_arithmetic t2 then
            exception`unit (a`T_EXP (t`usual_arithmetic t1 t2))
          else invalid msg_a e2
        else invalid_head msg_n))
    | a`BINARY (c`ARITHMETIC c`SUB) e1 e2 ->
        let msg_c = "Violation of constraint 6.5.6#3 Additive operators, \
                     Constraint: ``[B]oth operands [shall be] pointers to [...] \
                     compatible complete object types [...].`` (Operands are \
                     pointers to incompatible types.) in" in
        let msg_i = "Violation of constraint 6.5.6#3 Additive operators, \
                     Constraints: ``[B]oth operands [shall either be] pointers \
                     to [...] compatible complete object types[,] or the left \
                     operand [shall be] a pointer to a complete object type and \
                     the right operand [shall have] integer type.`` (We expected \
                     either a pointer or an integer type.) in" in
        let msg_a = "Violation of contraint 6.5.6#3 Additive operators, \
                     Constraints: ``[B]oth operands have arithmetic type [...].``
                     in" in
        let msg_n = "Violation of constraint 6.5.6#3 Additive operators, \
                     Constraints: ``[B]oth operands [shall] have arithmetic \
                     type[, or shall be] pointers to [...] compatible complete
                     object types[,] or the left operand [shall be] a pointer to \
                     a complete object type and the right operand [shall have]
                     integer type.`` in" in
        f e1 >>= (fun t1 ->
        f e2 >>= (fun t2 ->
        if t`is_pointer_to_complete_object t1 then
          (* Case: ptr - ptr. *)
          if t`is_pointer_to_complete_object t2 then
            if t`compatible t1 t2 then
              exception`fail "Computing the difference of two pointers is not yet \
                              supported.\n"
            else invalid_head msg_c
          else
            (* Case: ptr - int. *)
            if t`is_integer t2 then
              exception`unit (a`T_EXP t1)
            else invalid msg_i e2
        (* Case: arith - arith. *)
        else if t`is_arithmetic t1 then
          if t`is_arithmetic t2 then
            exception`unit (a`T_EXP (t`usual_arithmetic t1 t2))
          else invalid msg_a e2
        else invalid_head msg_n))
    | a`BINARY (c`ARITHMETIC c`SHL) e1 e2 ->
        check_exp env l (a`BINARY (c`ARITHMETIC c`SHL) e1 e2)
    | a`BINARY (c`ARITHMETIC c`SHR) e1 e2  ->
        let msg = "Violation of constraint 6.5.7#2 Bitwise shift operators, \
                   Constraints: ``Each of the operands shall have integer \
                   type.`` in" in
        f e1 >>= (fun t1 ->
        f e2 >>= (fun t2 ->
        if t`is_integer t1 then
          if t`is_integer t2 then
            exception`unit (a`T_EXP (t`promote t1))
          else invalid msg e2
        else invalid_head msg))
    | a`BINARY (c`RELATIONAL c`LT) e1 e2 ->
        check_exp env l (a`BINARY (c`RELATIONAL c`GE) e1 e2)
    | a`BINARY (c`RELATIONAL c`GT) e1 e2 ->
        check_exp env l (a`BINARY (c`RELATIONAL c`GE) e1 e2)
    | a`BINARY (c`RELATIONAL c`LE) e1 e2 ->
        check_exp env l (a`BINARY (c`RELATIONAL c`GE) e1 e2)
    | a`BINARY (c`RELATIONAL c`GE) e1 e2 ->
        let msg_c = "Violation of constraint 6.5.8#2 Relational operators, \
                     Constraints: ``[B]oth operands [shall be] pointers to [...] \
                     compatible object types.`` (Operands don't seem to be
                     compatible.) in" in
        let msg_p = "Violation of constraint 6.5.8#2 Relational operators, \
                     Constraints: ``[B]oth operands [shall be] pointers to [...] \
                     compatible object types.`` (Operand doesn't seem to be a \
                     pointer.) in" in
        let msg_r = "Violation of constraint 6.5.8#2 Relational operators, \
                     Constraints: ``[B]oth operands [shall] have real type \
                     [...].`` in" in
        let msg_n = "Violation of constraint 6.5.8#2 Relational operators, \
                     Constraints: ``One of the following shall hold: both \
                     operands have real type or both operands are pointers to \
                     [...] compatible types.`` in" in
        f e1 >>= (fun t1 ->
        f e2 >>= (fun t2 ->      
        if t`is_pointer_to_object t1 then
          if t`is_pointer_to_object t2 then
            if t`compatible t1 t2 then
              exception`unit (a`T_EXP int)
            else invalid_head msg_c
          else invalid msg_p e2
        else if t`is_real t1 then
          if t`is_real t2 then
            exception`unit (a`T_EXP int)
          else invalid msg_r e2
        else invalid_head msg_n))
    | a`BINARY (c`RELATIONAL c`EQ) e1 e2 ->
        check_exp env l (a`BINARY (c`RELATIONAL c`NE) e1 e2)
    | a`BINARY (c`RELATIONAL c`NE) e1 e2 ->
        let msg_v = "Constraint 6.5.9#2 Equality operators, Constraints: ``[O]ne \
                     operand is a pointer to an object type and the other is a \
                     pointer to [...] void [...].`` (Operand doesn't seem to be \
                     a pointer.) in" in
        let msg_p = "Constraint 6.5.9#2 Equality operators, Constraints: ``[O]ne \
                     operand [shall be] a pointer and the other [shall be] a \
                     null pointer constant.`` (Operand doesn't seem to be a \
                     pointer.) in" in
        let msg_c = "Constraint 6.5.9#2 Equality operators, Constraints: ``[O]ne \
                     operand [shall be] a pointer and the other [shall be] a \
                     null pointer constant.`` (Operands don't seem to point to \
                     compatible types.) in" in
        let msg_a = "Constraint 6.5.9#2 Equality operators, Constraints: \
                     ``[B]oth operands [shall] have arithmetic type.`` in" in
        let msg_n = "Constraint 6.5.9#2 Equality operators, Constraints: \
                     ``One of the following shall hold: both operands have \
                     arithmetic type[, or] both operands are pointers to [...] \
                     compatible types[, or] one operand is a pointer to an \
                     object type and the other is a pointer to [...] void[, or] \
                     one operand is a pointer and the other is a null pointer \
                     constant.`` in" in
        f e1 >>= (fun t1 ->
        f e2 >>= (fun t2 ->
        let req_obj_ptr =
          let require p result msg t e =
            if p t then
              exception`unit result
            else invalid msg e in
          require t`is_pointer_to_object (a`T_EXP int) in
        (* Case: void ptr == ptr. *)
        if t`is_pointer_to_void t1 then
          req_obj_ptr msg_v t2 e2
        (* Case: ptr == void ptr. *)
        else if t`is_pointer_to_void t2 then
          req_obj_ptr msg_v t1 e1
        (* Case: null ptr == ptr. *)
        else if is_null_pointer e1 && t`is_pointer t2 then
          exception`unit (a`T_EXP int)
        (* Case: ptr == null ptr. *)
        else if t`is_pointer t1 && is_null_pointer e2 then
          exception`unit (a`T_EXP int)
        (* Case: ptr == ptr. *)
        else if t`is_pointer t1 then
          if t`is_pointer t2 then
            if t`compatible t1 t2 then
              exception`unit (a`T_EXP int)
            else invalid_head msg_c
          else invalid msg_p e2
        (* Case: arith + arith. *)
        else if t`is_arithmetic t1 then
          if t`is_arithmetic t2 then
            exception`unit (a`T_EXP int)
          else invalid msg_a e2
        else invalid_head msg_n))
    |  a`BINARY (c`ARITHMETIC c`BAND) e1 e2 ->
        let msg = "Violation of constraint 6.5.10#2 Bitwise AND operator, \
                   Contraints: ``Each of the operands shall have integer type.`` \
                   in" in
        f e1 >>= (fun t1 ->
        f e2 >>= (fun t2 ->
        if t`is_integer t1 then
          if t`is_integer t2 then
            exception`unit (a`T_EXP (t`usual_arithmetic t1 t2))
          else invalid msg e1
        else invalid_head msg))
    |  a`BINARY (c`ARITHMETIC c`XOR) e1 e2 ->
        let msg = "Violation of constraint 6.5.11#2 Bitwise exclusive OR \
                   operator, Contraints: ``Each of the operands shall have \
                   integer type.`` in" in
        f e1 >>= (fun t1 ->
        f e2 >>= (fun t2 ->
        if t`is_integer t1 then
          if t`is_integer t2 then
            exception`unit (a`T_EXP (t`usual_arithmetic t1 t2))
          else invalid msg e1
        else invalid_head msg))
    |  a`BINARY (c`ARITHMETIC c`BOR) e1 e2 ->
        let msg = "Violation of constraint 6.5.12#2 Bitwise inclusive OR \
                   operator, Contraints: ``Each of the operands shall have \
                   integer type.`` in" in
        f e1 >>= (fun t1 ->
        f e2 >>= (fun t2 ->
        if t`is_integer t1 then
          if t`is_integer t2 then
            exception`unit (a`T_EXP (t`usual_arithmetic t1 t2))
          else invalid msg e1
        else invalid_head msg))
    |  a`BINARY (c`SEQUENTIAL c`AND) e1 e2 ->
        let msg = "Violation of constraint 6.5.13#2 Logical AND operator, \
                   Constraints: ``Each of the operands shall have scalar type.`` \
                   in" in
        f e1 >>= (fun t1 ->
        f e2 >>= (fun t2 ->
        if t`is_scalar t1 then
          if t`is_scalar t2 then
            exception`unit (a`T_EXP int)
          else invalid msg e1
        else invalid_head msg))
    |  a`BINARY (c`SEQUENTIAL c`OR) e1 e2 ->
        let msg = "Violation of constraint 6.5.14#2 Logical OR operator, \
                   Contraints: ``Each of the operands shall have scalar type.`` \
                   in" in
        f e1 >>= (fun t1 ->
        f e2 >>= (fun t2 ->
        if t`is_scalar t1 then
          if t`is_scalar t2 then
            exception`unit (a`T_EXP int)
          else invalid msg e1
        else invalid_head msg))
    |  a`QUESTION e1 e2 e3 ->
        let msg_s = "Violation of constraint 6.5.15#2 Conditional operator, \
                    Constraints: ``The first operand shall have scalar type.`` \
                    in" in
        let msg_np = "Violation of constraint 6.5.15#3 Conditional operator, \
                      Constraints: ``[T]he following shall hold for the \
                      second and third operands: [...] one is a pointer and the \
                      other is a null pointer constant [...].`` (Operand doesn't \
                      seem to be a pointer.) in" in
        let msg_vp = "Violation of constraint 6.5.15#3 Conditional operator, \
                      Constraints: ``[T]he following shall hold for the second \
                      and third operands: [...] one operand is a pointer to an \
                      object type and the other is a pointer to [...] void.`` \
                      (Operand doesn't seem to be a pointer to an object type.)
                      in" in
        let msg_p = "Violation of constraint 6.5.15#3 Conditional operator, \
                     Constraints: ``[T]he following shall hold for the second \
                     and third operands: [...] both operands are pointers to \
                     compatible types [...].`` (Operand doesn't seem to be a \
                     pointer.) in" in
        let msg_c = "Violation of constraint 6.5.15#3 Conditional operator, \
                     Constraints: ``[T]he following shall hold for the second \
                     and third operands: [...] both operands are pointers to \
                     compatible types [...].`` (Operands don't seem to point to \
                     compatible types.) in" in
        let msg_v = "Violation of constraint 6.5.15#3 Conditional operator, \
                     Constraints: ``[T]he following shall hold for the second \
                     and third operands: [...] both operands have void type \
                     [...].`` in" in
        let msg_a = "Violation of constraint 6.5.15#3 Conditional operator, \
                     Constraints: ``[T]he following shall hold for the second \
                     and third operands: [...] both operands have arithmetic \
                     type [...].`` in" in
        let msg_u = "Violation of constraint 6.5.15#3 Conditional operator, \
                     Constraints: ``[T]he following shall hold for the second \
                     and third operands: [...] both operands have the same \
                     structure or union type [...].`` in" in
        let msg_n = "Violation of constraint 6.5.15#3 Conditional operator, \
                     Constraints: ``One of the following shall hold for the \
                     second and third operands: [Either] both operands have \
                     arithmetic type[, or] both operands have the same structure \
                     or union type[, or] both operands have void type[, or] both \
                     operands are pointers to [...] compatible types[, or] one \
                     operand is a pointer and the other is a null pointer \
                     constant[, or] one operand is a pointer to an object type \
                     and the other is a pointer [...] to void.`` in" in
        f e1 >>= (fun t1 ->
        f e2 >>= (fun t2 ->
        f e3 >>= (fun t3 ->
        (* First operand must be scalar. *)
        if t`is_scalar t1 then
          (* Case: null ptr : ptr. *)
          if is_null_pointer e2 && t`is_pointer t3 then
            exception`unit (a`T_EXP (t`include_qualifiers t3 (t`qualifiers t2)))
          (* Case: ptr : null ptr. *)
          else if t`is_pointer t2 && is_null_pointer e3 then
            exception`unit (a`T_EXP (t`include_qualifiers t2 (t`qualifiers t3)))
          (* Case: void ptr : ptr.
             Note that, since void is also an object, there is no need to deal
             with the case ptr : void ptr separately. *)
          else if t`is_pointer_to_void t2 then
            if t`is_pointer_to_object t3 then
              let q = t`merge_qualifiers t2 t3 in
              exception`unit (a`T_EXP (a`POINTER q (a`BASE empty a`VOID)))
            else invalid msg_vp e3
          (* Case: ptr : ptr. *)
          else if t`is_pointer t2 then
            if t`is_pointer t3 then
              if t`compatible t2 t3 then
                let q = t`merge_qualifiers t2 t3 in
                exception`of_option msg_c (t`composite t2 t3) >>= (fun t ->
                exception`unit (a`T_EXP (t`include_qualifiers t q)))
              else invalid_head msg_c
            else invalid msg_p e3
          (* Case: arith : arith. *)
          else if t`is_arithmetic t2 then
            if t`is_arithmetic t3 then
              exception`unit (a`T_EXP (t`common (t`promote t2) (t`promote t3)))
            else invalid msg_a e3
          (* Case: void : void. *)
          else if t`is_void t2 then
            if t`is_void t3 then
              exception`unit (a`T_EXP (a`BASE empty a`VOID))
            else invalid msg_v e3
          (* Case: struct : struct, enum : enum. *)
          else if t`is_structure t2 || t`is_union t2 then
            if t2 = t3 then
              exception`unit (a`T_EXP t2)
            else invalid msg_u e3
          else invalid_head msg_n
        else invalid msg_s e1)))
    | a`ASSIGN None e1 e2 ->
        let msg_l = "Violation of constraint 6.5.16#1 Assignment operators, \
                     Constraints: ``An assignment operator shall have a \
                     modifiable lvalue as its left operand.`` in" in
        let msg_b = "Violation of constraint 6.5.16.1#1 Simple assignment, \
                     Constraints: ``[T]he left operand has type [...] _Bool, and \
                     the right is a pointer.`` (Operand doesn't seem to be a \
                     pointer.) in" in
        let msg_sc = "Violation of constraint 6.5.16.1#1 Simple assignment, \
                      Constraints: ``[T]he left operand has [...] structure or \
                      union type compatible with the type of the right [...]`` ( \
                      Operands don't seem to have compatible types.) in" in
        let msg_a = "Violation of constraint 6.5.16.1#1 Simple assignment, \
                     Constraints: ``[T]he left operand [shall have] arithmetic \
                     [...] type, and the right [shall have] arithmetic type \
                     [...]..`` in" in
        let msg_vq = "Violation of constraint 6.5.16.1#1 Simple assignment, \
                      Constraints: ``[T]he left operand [shall have] [...] \
                      pointer type, and [...] one operand [shall be] a pointer \
                      to an object type, and the other [shall be] a pointer to \
                      [...] void, and the type pointed to by the left has all \
                      the qualifiers of type pointed to by the right [...].`` \
                      (Left operand doesn't seem to have all the qualifiers of \
                      the right operand.) in" in
        let msg_v = "Violation of constraint 6.5.16.1#1 Simple assignment, \
                     Constraints: ``[T]he left operand [shall have] [...] \
                     pointer type, and [...] one operand [shall be] a pointer to \
                     an object type, and the other [shall be] a pointer to [...] \
                     void [...].`` (Operand doesn't seem to be a pointer to an \
                     object type.) in" in
        let msg_cq = "Violation of constraint 6.5.16.1#1 Simple assignment, \
                      Constraints: ``[T]he left operand [shall have] [...] \
                      pointer type and [...] both operands [shall be] pointers \
                      to [...] compatible types, and the type pointed to by the \
                      left [shall have] all the qualifiers of the type pointed \
                      to by the right [...].`` (Left operand doesn't seem to \
                      have all the qualifiers of the right operand.) in" in
        let msg_c = "Violation of constraint 6.5.16.1#1 Simple assignment, \
                     Constraints: ``[T]he left operand [shall have] [...] \
                     pointer type and [...] both operands [shall be] pointers to \
                     [...] compatible types [...].`` (Operands don't seem to \
                     point to compatible types.) in" in
        let msg_n = "Violation of constraint 6.5.16.1#1 Simple assignment, \
                     Constraints: ``One of the following shall hold: the left \
                     operand has [...] arithmetic type, and the right has \
                     arithmetic type[, or] the left operand has [...] structure \
                     or union type compatible with the type of the right[, or] \
                     the left operand has [...] pointer type, and [...] both \
                     operands are pointer to [...] compatible types, and the \
                     type pointed to by the left has all the qualifiers of the \
                     type pointed to by the right[, or] the left operand has \
                     [...] pointer type, and [...] one operand is a pointer to \
                     an object type, and the other is a pointer to [...] void, \
                     and the type pointed to by the left has all the qualifiers \
                     of the type pointed to by the right[, or] the left operand \
                     is [a] [...] pointer, and the right is a null pointer \
                     constant[, or] the left operand has type [...] _Bool, and \
                     the right is a pointer.`` in" in
        f_lvalue msg_l e1 >>= (fun t1 ->
        f e2 >>= (fun t2 ->   
        lvalue_convert t1 e1 >>= (fun t_head ->
        let base_has_all_qualifiers t1 t2 =
          let b1 = t`base_of_pointer t1 in
          let b2 = t`base_of_pointer t2 in
          Set`is_subset (t`qualifiers b2) (t`qualifiers b1) in
        if t`is_modifiable t1 then
          (* Case: bool = ptr. *)
          if t`is_bool t1 then
            if t`is_pointer t2 then
              exception`unit (a`T_EXP t_head)
            else invalid msg_b e2
          (* Case struct = struct or enum = enum. *)
          else if t`is_structure t1 || t`is_enum t1 then
            if t`compatible t1 t2 then
              exception`unit (a`T_EXP t_head)
            else invalid msg_sc e2
          (* Case: arith = arith. *)
          else if t`is_arithmetic t1 then
            if t`is_arithmetic t2 then
              exception`unit (a`T_EXP t_head)
            else invalid msg_a e2
          (* Cases of the form ptr = _. *)
          else if t`is_pointer t1 then
            (* Case ptr = null ptr. *)
            if is_null_pointer e2 then
              exception`unit (a`T_EXP t_head)
            (* Case: void ptr = ptr. *)
            else if t`is_pointer_to_void t1 then
              if t`is_pointer_to_object t2 then
                if base_has_all_qualifiers t1 t2 then
                  exception`unit (a`T_EXP t_head)
                else invalid_head msg_vq
              else invalid msg_v e2
            (* Case: ptr = void ptr. *)
            else if t`is_pointer_to_void t2 then
              if t`is_pointer_to_object t1 then
                if base_has_all_qualifiers t1 t2 then
                  exception`unit (a`T_EXP t_head)
                else invalid_head msg_vq
              else invalid msg_v e1
            (* Case: ptr = ptr. *)
            else if t`is_pointer t2 then
              if t`compatible t1 t2 then
                if base_has_all_qualifiers t1 t2 then
                  exception`unit (a`T_EXP t_head)
                else invalid_head msg_cq
              else invalid_head msg_c
            else invalid_head msg_n
          else invalid_head msg_n
        else invalid msg_l e1)))
    | a`ASSIGN (Some c`ADD) e1 e2 ->
        check_exp env l (a`ASSIGN (Some c`SUB) e1 e2)
    | a`ASSIGN (Some c`SUB) e1 e2 ->
        let msg_l = "Violation of constraint 6.5.16#2 Assignment operators, \
                     Constraints: ``An assignment operator shall have a \
                     modifiable lvalue as its left operand.`` in" in
        let msg_i = "Violation of constraint 6.5.16.2#1 Compound assignment,
                     Constraints: ``[T]he left operand shall be [a] [...] \
                     pointer to a complete object type, and the right shall have \
                     integer type [...].`` (Operand doesn't seem to have integer \
                     type.) in" in
        let msg_a = "Violation of constraint 6.5.16.2#1 Compound assignment,
                     Constraints: ``[T]he left operand shall have [...] \
                     arithmetic type, and the right shall have arithmetic \
                     type.`` (Operand doesn't seem to have  arithmetic type.)`` \
                     in" in
        let msg_n = "Violation of constraint 6.5.16.2#1 Compound assignment,
                     Constraints: ``For the operators += and -= only, either the \
                     left operand shall be [a] [...] pointer to a complete \
                     object type, and the right shall have integer type[, or] \
                     the left operand shall have [...] arithmetic type and the \
                     right shall have arithmetic type.`` in" in
        f_lvalue msg_l e1 >>= (fun t1 ->
        f e2 >>= (fun t2 ->
        lvalue_convert t1 e1 >>= (fun t_head ->
        if t`is_modifiable t1 then
          if t`is_pointer_to_complete_object t1 then
            if t`is_integer t2 then
              exception`unit (a`T_EXP t_head)
            else invalid msg_i e2
          else if t`is_arithmetic t1 then
            if t`is_arithmetic t2 then
              exception`unit (a`T_EXP t_head)
            else invalid msg_a e2
          else invalid_head msg_n
        else invalid msg_l e1)))
    | a`ASSIGN (Some o) e1 e2 ->
        let msg_l = "Violation of constraint 6.5.16#2 Assignment operators, \
                     Constraints: ``An assignment operator shall have a \
                     modifiable lvalue as its left operand.`` in" in
        let msg_a = "Violation of constraint 6.5.16.2#2 Compound assignment, \
                     Constraints: ``[T]he left operand shall have [...] \
                     arithmetic type [...].`` in" in
        f_lvalue msg_l e1 >>= (fun t1 ->
        lvalue_convert t1 e1 >>= (fun t_head ->
        if t`is_modifiable t1 then
          if t`is_arithmetic t1 then
            let bexp = a`BINARY (c`ARITHMETIC o) e1 e2 in
            check_exp env l bexp >>= (fun _ ->
            exception`unit (a`T_EXP t_head))
          else invalid msg_a e1
        else invalid msg_l e1))
    | a`BINARY (c`SEQUENTIAL c`COMMA) e1 e2 ->
        f e1 >>= (fun _ ->
	f e2 >>= (fun t ->
        exception`unit (a`T_EXP t)))
  end

| annotate_exp env exp =
  let (a`Exp l e) = exp in
  let a_type e =
    exception`map (fun t -> a`Exp (aa`a_type l t) e) (check_exp env l e) in
  match e with
    | a`VARIABLE v -> a_type (a`VARIABLE v)
    | a`CONSTANT c -> a_type (a`CONSTANT c)
    | a`SIZEOF   t -> a_type (a`SIZEOF   t)
    | a`ALIGNOF  t -> a_type (a`ALIGNOF  t)
    | _ ->
        let map_exp f exp =
          match exp with
            | a`UNARY o e -> exception`map (a`UNARY o) (f e)
            | a`BINARY o e1 e2 -> exception`map2 (a`BINARY o) (f e1) (f e2)
            | a`ASSIGN o e1 e2 -> exception`map2 (a`ASSIGN o) (f e1) (f e2)
            | a`QUESTION e1 e2 e3 -> exception`map3 a`QUESTION (f e1) (f e2) (f e3)
            | a`CAST t e -> exception`map (a`CAST t) (f e)
            | a`CALL e es -> exception`map2 (a`CALL) (f e) (exception`map_list f es)
            | a`CONSTANT c -> exception`unit (a`CONSTANT c)
            | a`VARIABLE v -> exception`unit (a`VARIABLE v)
            | a`SIZEOF   t -> exception`unit (a`SIZEOF   t)
            | a`ALIGNOF  t -> exception`unit (a`ALIGNOF  t)
          end in
        let f exp = annotate_exp env exp in
        exception`bind (map_exp f e) a_type
  end

let rec annotate_stmt env (a`Stmt l stmt) =
  let f_e = annotate_exp env in
  let f_s = annotate_stmt env in
  let type_of e =
    let t =
      match aa`type_of e with
        | a`T_EXP    t -> exception`unit t
        | a`T_LVALUE t -> lvalue_convert t e
      end in
    exception`map t`pointer_convert t in
  exception`map (a`Stmt l) (match stmt with
    | a`IF e s1 s2 ->
        let msg_s = "Violation of constraint 6.8.4.1 The if statement, \
                     Constraints: ``The controlling expression of an if \
                     statement shall have scalar type.`` in" in
        f_e e      >>= (fun e' ->
        type_of e' >>= (fun t  ->
        if t`is_scalar t then
          exception`map2 (a`IF e') (f_s s1) (f_s s2)
        else invalid msg_s e'))
    | a`SWITCH _ _ -> exception`fail "No support for switch statements yet."
    | a`WHILE e s ->
        let msg_s = "Violation of constraint 6.8.4.1 Iteration statements, \
                     Constraints: ``The controlling expression of an iteration \
                     statement shall have scalar type.`` in" in
        f_e e      >>= (fun e' ->
        type_of e' >>= (fun t  ->
        if t`is_scalar t then
          exception`map (a`WHILE e') (f_s s)
        else invalid msg_s e'))
    | a`DO e s ->
        let msg_s = "Violation of constraint 6.8.4.1 Iteration statements, \
                     Constraints: ``The controlling expression of an iteration \
                     statement shall have scalar type.`` in" in
        f_e e      >>= (fun e' ->
        type_of e' >>= (fun t  ->
        if t`is_scalar t then
          exception`map (a`DO e') (f_s s)
        else invalid msg_s e'))
    | _ ->
        let map_stmt fs fe stmt =
          match stmt with
            | a`EXPRESSION e -> exception`map a`EXPRESSION (fe e)
            | a`BLOCK ids sl -> exception`map (a`BLOCK ids) (exception`map_list fs sl)
            | a`IF e s1 s2 -> exception`map3 a`IF (fe e) (fs s1) (fs s2)
            | a`WHILE e s -> exception`map2 a`WHILE (fe e) (fs s)
            | a`DO e s -> exception`map2 a`DO (fe e) (fs s)
            | a`RETURN_EXPRESSION e -> exception`map a`RETURN_EXPRESSION (fe e)
            | a`SWITCH e s -> exception`map2 a`SWITCH (fe e) (fs s)
            | a`CASE c s -> exception`map (a`CASE c) (fs s)
            | a`DEFAULT s -> exception`map a`DEFAULT (fs s)
            | a`LABEL id s -> exception`map (a`LABEL id) (fs s)
            | a`DECLARATION dl ->
                exception`map a`DECLARATION (exception`map_list (exception`inj_right fe) dl)
            | a`SKIP -> exception`unit a`SKIP
            | a`BREAK -> exception`unit a`BREAK
            | a`CONTINUE -> exception`unit a`CONTINUE
            | a`RETURN_VOID -> exception`unit a`RETURN_VOID
            | a`GOTO id -> exception`unit (a`GOTO id)
          end in
        map_stmt f_s f_e stmt
  end)

let annotate_program p =
  let () =
    if not (Pmap`for_all (fun _ -> t`well_formed) p.a`id_map) then () else () in
  exception`map_list (exception`inj_right (annotate_exp  p)) p.a`globals >>= (fun gs ->
  exception`map_map  (exception`inj_right (annotate_stmt p)) p.a`fn_map  >>= (fun fs ->
  exception`unit <|
    a`main = p.a`main;
    a`id_map = p.a`id_map;
    a`globals = gs;
    a`fn_map = fs
  |>))

let annotate file = annotate_program file
