open import Pervasives Ctype
open import Assert_extra

import Symbol

open import Core
open import Mucore Annot
     import Annot Core_typing Core_typing_aux 



let rec ib_expr 
          (label : symbol * list symbol * mu_expr 'DCTY 'DBTY 'bty)
          (e : mu_expr 'DCTY 'DBTY 'bty) 
           : mu_expr 'DCTY 'DBTY 'bty =
  let (M_Expr oannots e_) = e in
  let wrap e_ = M_Expr oannots e_ in
  let aux = ib_expr label in
  match e_ with
  | M_Epure _ -> wrap e_
  | M_Ememop _ -> wrap e_
  | M_Eaction _ -> wrap e_
  | M_Ecase asym pats_es ->
     let pats_es = 
       List.map (fun (pat,e) -> 
           (pat, aux e)
         ) pats_es
     in
     wrap (M_Ecase asym pats_es)
 | M_Elet sym_or_pat pe e ->
    wrap (M_Elet sym_or_pat pe (aux e))
 | M_Eif asym e1 e2 ->
    let e1 = aux e1 in
    let e2 = aux e2 in
    wrap (M_Eif asym e1 e2)
 | M_Eskip -> wrap e_
 | M_Eccall _ _ _ -> wrap e_
 | M_Eproc _ _ -> wrap e_
 | M_Ewseq pat e1 e2 -> 
    let e1 = aux e1 in
    let e2 = aux e2 in
    wrap (M_Ewseq pat e1 e2)
 | M_Esseq pat e1 e2 ->
    let e1 = aux e1 in
    let e2 = aux e2 in
    wrap (M_Esseq pat e1 e2)
 | M_Ebound n e ->
    let e = aux e in
    wrap (M_Ebound n e)
 | M_End es ->
    let es = map aux es in
    wrap (M_End es)
 | M_Erun l args -> 
    let (label_sym, label_arg_syms, label_body) = label in
    if not (label_sym = l) then e
    else if List.length label_arg_syms <> List.length args then
      failwith "M_Erun supplied wrong number of arguments"
    else
      let () = Debug.print_debug 1 [] (fun () -> ("REPLACING LABEL " ^ show l)) in
      let arguments = List.zip label_arg_syms args in
      let (M_Expr annots e_) = 
        List.foldr (fun (spec_arg, A annots bty app_arg) body ->
            let pe = M_Pexpr annots bty (M_PEsym app_arg) in
            M_Expr [] (M_Elet (M_Symbol spec_arg) pe body)
          ) label_body arguments
      in
      (* this combines annotations *)
      M_Expr (annots ++ oannots) e_
  end
    


let rec inline_label_labels_and_body to_inline to_keep body =
  match to_inline with
  | [] -> (to_keep, body)
  | l :: to_inline' ->
     let to_inline' = 
       map (fun (lname,arg_syms,lbody) -> 
           (lname,arg_syms,ib_expr l lbody)
         ) to_inline'
     in
     let to_keep' = 
       Map.map (fun def -> match def with
         | M_Return _ -> def
         | M_Label lt args lbody2 annot -> 
            M_Label lt args (ib_expr l lbody2) annot
         end) to_keep
     in
     let body' = ib_expr l body in
     inline_label_labels_and_body to_inline' to_keep' body'
  end


let ib_fun_map_decl 
      (name: symbol)
      (d : mu_fun_map_decl 'DLTY 'DCTY 'DBTY 'bty) 
    : mu_fun_map_decl 'DLTY 'DCTY 'DBTY 'bty =
  better_error_messages (show name)
    (match d with
     | M_Proc loc rbt arg_bts body label_defs -> 
        let (to_keep, to_inline) =
          let aux label def (to_keep, to_inline) =
            match def with
            | M_Return _ -> (Map.insert label def to_keep, to_inline)
            | M_Label lt args lbody annot ->
               if is_loop_break annot
               then (to_keep, (label, map fst args, lbody) :: to_inline)
               else (Map.insert label def to_keep, to_inline)
            end 
          in
          Map_extra.fold aux label_defs (Map.empty, [])
        in
        let (label_defs, body) = 
          inline_label_labels_and_body to_inline to_keep body
        in
        M_Proc loc rbt arg_bts body label_defs
     | _ -> d
     end)

let ib_fun_map (fmap : mu_fun_map 'DLTY 'DCTY 'DBTY 'bty) 
    : mu_fun_map 'DLTY 'DCTY 'DBTY 'bty = 
  Map.mapi ib_fun_map_decl fmap
  

let ib_globs (g : mu_globs 'DCTY 'DBTY 'bty) 
    : mu_globs 'DCTY 'DBTY 'bty = 
  match g with
  | M_GlobalDef bt e -> M_GlobalDef bt e
  | M_GlobalDecl bt -> M_GlobalDecl bt 
  end

let ib_globs_list (gs : mu_globs_list 'DCTY 'DBTY 'bty)
    : mu_globs_list 'DCTY 'DBTY 'bty = 
  map (fun (sym,g) -> (sym, ib_globs g)) gs


let ib_file file =
  <| file with mu_stdlib = ib_fun_map file.mu_stdlib
             ; mu_globs = ib_globs_list file.mu_globs
             ; mu_funs = ib_fun_map file.mu_funs
  |>

