open import Pervasives

open import Ctype Annot Loc
import Symbol Implementation Undefined Cmm_csem
open import Mem Mem_common
(* import Linux *)

import Core
open import Core_aux

open import Assert_extra


val better_error_messages : forall 'a. string -> 'a -> 'a
declare ocaml target_rep function better_error_messages message a = 
  `try` a `with | Failure error -> failwith (` message ` ^ error) `





type symbol = Symbol.sym
type mu_object_type = Core.core_object_type
type mu_base_type = Core.core_base_type
(* type bty = mu_base_type *)
type mu_name = Core.generic_name symbol

type A 'o 'bty = A of list Annot.annot * 'bty * 'o
let a_unpack (A _ _ a) = a
let a_pack annots bty a = A annots bty a

type asym 'bty = A Symbol.sym 'bty

(* type mv_tsymbol = tsymbol       (\* Mem.mem_value *\) *)
type ov_asym 'bty = asym 'bty       (* object_value *)
type lv_asym 'bty = asym 'bty       (* loaded_value *)
type va_asym 'bty = asym 'bty       (* value *)







type mu_object_value 'DCTY 'bty =  (* C object values *)
 | M_OVinteger of Mem.integer_value (* integer value *)
 | M_OVfloating of Mem.floating_value (* floating-point value *)
 | M_OVpointer of Mem.pointer_value (* pointer value *)
 | M_OVarray of list (lv_asym 'bty) (* C array value *)
 | M_OVstruct of symbol * list (Symbol.identifier * 'DCTY * Mem.mem_value) (* C struct value *)
 | M_OVunion of symbol * Symbol.identifier * Mem.mem_value (* C union value *)

type mu_loaded_value 'DCTY 'bty =  (* potentially unspecified C object values *)
 | M_LVspecified of mu_object_value 'DCTY 'bty (* non-unspecified loaded value *)
 (* | M_LVunspecified of 'DCTY (\* unspecified loaded value *\) *)


(* again, we might remove something from the definition here,
   e.g. Vctype *)
type mu_value 'DCTY 'DBTY 'bty =  (* Core values *)
 | M_Vobject of mu_object_value 'DCTY 'bty (* C object value *)
 | M_Vloaded of mu_loaded_value 'DCTY 'bty (* loaded C object value *)
 | M_Vunit
 | M_Vtrue
 | M_Vfalse
 (* | M_Vctype of 'DCTY (\* C type as value *\) *)
 | M_Vlist of 'DBTY * list (asym 'bty)
 | M_Vtuple of list (asym 'bty) (* tuple *)



type mu_ctor 'DBTY =  (* data constructors *)
 | M_Cnil of 'DBTY (* empty list *) 
 (* annotated with the type of the list items *)
 | M_Ccons (* list cons *)
 | M_Ctuple (* tuple *)
 | M_Carray (* C array *)
 | M_CivCOMPL (* bitwise complement *)
 | M_CivAND (* bitwise AND *)
 | M_CivOR (* bitwise OR *)
 | M_CivXOR (* bitwise XOR *)
 | M_Cspecified (* non-unspecified loaded value *)
 | M_Cfvfromint (* cast integer to floating value *)
 | M_Civfromfloat (* cast floating to integer value *)
 (* | M_Cunspecified (\* unspecified loaded value *\) *)
 (* | M_Civmax (\* max integer value *\)
  * | M_Civmin (\* min integer value *\)
  * | M_Civsizeof (\* sizeof value *\)
  * | M_Civalignof (\* alignof value *\) *)

type mu_pattern_ 'DBTY = 
 | M_CaseBase of (maybe Symbol.sym * 'DBTY)
 | M_CaseCtor of mu_ctor 'DBTY * list (mu_pattern 'DBTY)

and mu_pattern 'DBTY = 
 | M_Pattern of list annot * (mu_pattern_ 'DBTY)

type mu_sym_or_pattern 'DBTY 'bty = 
  | M_Symbol of symbol
  | M_Pat of mu_pattern 'DBTY

type mu_pexpr_ 'DCTY 'DBTY 'bty =  (* Core pure expressions *)
 | M_PEsym of symbol
 | M_PEimpl of Implementation.implementation_constant (* implementation-defined constant *)
 | M_PEval of mu_value 'DCTY 'DBTY 'bty
 | M_PEconstrained of list (Mem.mem_iv_constraint * asym 'bty) (* constrained value *)
 | M_PEundef of Loc.t * Undefined.undefined_behaviour (* undefined behaviour *)
 | M_PEerror of string * asym 'bty (* impl-defined static error *)
 | M_PEctor of mu_ctor 'DBTY * list (asym 'bty) (* data constructor application *)
 | M_PEcase of (asym 'bty) * list (mu_pattern 'DBTY * mu_pexpr 'DCTY 'DBTY 'bty) (* pattern matching *)
 | M_PEarray_shift of (asym 'bty) * 'DCTY * (asym 'bty) (* pointer array shift *)
 | M_PEmember_shift of (asym 'bty) * symbol * Symbol.identifier (* pointer struct/union member shift *)
 | M_PEnot of asym 'bty (* boolean not *)
 | M_PEop of Core.binop * (asym 'bty) * (asym 'bty)
 | M_PEstruct of symbol * list (Symbol.identifier * asym 'bty) (* C struct expression *)
 | M_PEunion of symbol * Symbol.identifier * asym 'bty (* C union expression *)
 (* | M_PEcfunction of asym 'bty (\* C function pointer expression *\) *)
 | M_PEmemberof of symbol * Symbol.identifier * asym 'bty (* C struct/union member access *)
 | M_PEcall of mu_name * list (asym 'bty) (* pure function call *)
 | M_PElet of (mu_sym_or_pattern 'DBTY 'bty) * (mu_pexpr 'DCTY 'DBTY 'bty) * (mu_pexpr 'DCTY 'DBTY 'bty) (* pure let *)
 | M_PEif of asym 'bty * (mu_pexpr 'DCTY 'DBTY 'bty) * (mu_pexpr 'DCTY 'DBTY 'bty) (* pure if *)
 (* | M_PEis_scalar of asym 'bty
  * | M_PEis_integer of asym 'bty
  * | M_PEis_signed of asym 'bty
  * | M_PEbmc_assume of asym 'bty
  * | M_PEis_unsigned of asym 'bty
  * | M_PEare_compatible of asym 'bty * asym 'bty *)

and mu_pexpr 'DCTY 'DBTY 'bty = 
 | M_Pexpr of list annot * 'bty * (mu_pexpr_ 'DCTY 'DBTY 'bty)



type mu_action_ 'DCTY 'bty =  (* memory actions *)
 | M_Create of asym 'bty * (A 'DCTY 'bty) * Symbol.prefix
 | M_CreateReadOnly of asym 'bty * (A 'DCTY 'bty) * asym 'bty * Symbol.prefix
 | M_Alloc of (A 'DCTY 'bty) * asym 'bty * Symbol.prefix
 | M_Kill of bool * asym 'bty (* the boolean indicates whether the action is dynamic (i.e. free()) *)
 | M_Store of bool * (A 'DCTY 'bty) * asym 'bty * asym 'bty * Cmm_csem.memory_order (* the boolean indicates whether the store is locking *)
 | M_Load of (A 'DCTY 'bty) * asym 'bty * Cmm_csem.memory_order
 | M_RMW of (A 'DCTY 'bty) * asym 'bty * asym 'bty * asym 'bty * Cmm_csem.memory_order * Cmm_csem.memory_order
 | M_Fence of Cmm_csem.memory_order
 | M_CompareExchangeStrong of (A 'DCTY 'bty) * asym 'bty * asym 'bty * asym 'bty * Cmm_csem.memory_order * Cmm_csem.memory_order
 | M_CompareExchangeWeak of (A 'DCTY 'bty) * asym 'bty * asym 'bty * asym 'bty * Cmm_csem.memory_order * Cmm_csem.memory_order
 | M_LinuxFence of Linux.linux_memory_order
 | M_LinuxLoad of (A 'DCTY 'bty) * asym 'bty * Linux.linux_memory_order
 | M_LinuxStore of (A 'DCTY 'bty) * asym 'bty * asym 'bty * Linux.linux_memory_order
 | M_LinuxRMW of (A 'DCTY 'bty) * asym 'bty * asym 'bty * Linux.linux_memory_order


type mu_action 'DCTY 'bty = 
 | M_Action of Loc.t * (mu_action_ 'DCTY 'bty)


type mu_paction 'DCTY 'bty =  (* memory actions with Core.polarity *)
 | M_Paction of Core.polarity * (mu_action 'DCTY 'bty)

type mu_memop 'DCTY 'bty =
  | M_PtrEq of (asym 'bty * asym 'bty)
  | M_PtrNe of (asym 'bty * asym 'bty)
  | M_PtrLt of (asym 'bty * asym 'bty)
  | M_PtrGt of (asym 'bty * asym 'bty)
  | M_PtrLe of (asym 'bty * asym 'bty)
  | M_PtrGe of (asym 'bty * asym 'bty)
  | M_Ptrdiff of ((A 'DCTY 'bty) * asym 'bty * asym 'bty)
  | M_IntFromPtr of ((A 'DCTY 'bty) * asym 'bty)
  | M_PtrFromInt of ((A 'DCTY 'bty) * asym 'bty)
  | M_PtrValidForDeref of ((A 'DCTY 'bty) * asym 'bty  )
  | M_PtrWellAligned of ((A 'DCTY 'bty) * asym 'bty  )
  | M_PtrArrayShift of (asym 'bty * (A 'DCTY 'bty) * asym 'bty  )
  | M_Memcpy of (asym 'bty * asym 'bty * asym 'bty)
  | M_Memcmp of (asym 'bty * asym 'bty * asym 'bty)
  | M_Realloc of (asym 'bty * asym 'bty * asym 'bty)
  | M_Va_start  of (asym 'bty * asym 'bty)
  | M_Va_copy of (asym 'bty)
  | M_Va_arg of (asym 'bty * (A 'DCTY 'bty))
  | M_Va_end of (asym 'bty)


type mu_expr_ 'DFTY 'DCTY 'DBTY 'bty =  (* (effectful) expression *)
 | M_Epure of (mu_pexpr 'DCTY 'DBTY 'bty)
 | M_Ememop of mu_memop 'DCTY 'bty
 | M_Eaction of (mu_paction 'DCTY 'bty) (* memory action *)
 | M_Ecase of asym 'bty * list (mu_pattern 'DBTY * (mu_expr 'DFTY 'DCTY 'DBTY 'bty)) (* pattern matching *)
 | M_Elet of (mu_sym_or_pattern 'DBTY 'bty) * (mu_pexpr 'DCTY 'DBTY 'bty) * (mu_expr 'DFTY 'DCTY 'DBTY 'bty)
 | M_Eif of asym 'bty * (mu_expr 'DFTY 'DCTY 'DBTY 'bty) * (mu_expr 'DFTY 'DCTY 'DBTY 'bty)
 | M_Eskip
 | M_Eccall of ((A 'DCTY 'bty)) * asym 'bty * list (asym 'bty) (* C function call *)
 | M_Eproc of mu_name * list (asym 'bty) (* Core procedure call *)
 (* | M_Eunseq of list (mu_expr 'DBTY 'bty) (\* unsequenced expressions *\) *)
 | M_Ewseq of mu_pattern 'DBTY * (mu_expr 'DFTY 'DCTY 'DBTY 'bty) * (mu_expr 'DFTY 'DCTY 'DBTY 'bty) (* weak sequencing *)
 | M_Esseq of mu_pattern 'DBTY * (mu_expr 'DFTY 'DCTY 'DBTY 'bty) * (mu_expr 'DFTY 'DCTY 'DBTY 'bty) (* strong sequencing *)
 (* | M_Easeq of (symbol * 'DBTY) * (mu_action 'bty) * (mu_paction 'bty) (\* atomic sequencing *\) *)
 (* | M_Eindet of nat * (mu_expr 'DBTY 'bty) (\* indeterminately sequenced expr *)
 | M_Ebound of nat * (mu_expr 'DFTY 'DCTY 'DBTY 'bty) (* $\ldots$and boundary *)
 | M_End of list (mu_expr 'DFTY 'DCTY 'DBTY 'bty) (* nondeterministic choice *)
 | M_Erun of symbol * list (asym 'bty) * maybe (esave 'DFTY 'DCTY 'DBTY 'bty) (* run from label *)
 (* | M_Epar of list (mu_expr 'DBTY 'bty) (\* cppmem-like thread creation *\) *)
 (* | M_Ewait of Mem_common.thread_id (\* wait for thread termination *\) *)

and esave 'DFTY 'DCTY 'DBTY 'bty = 
  | M_Esave of 'DFTY * (symbol * ('DBTY * 'DCTY)) * list (symbol * (('DBTY * 'DCTY) * asym 'bty)) * (mu_expr 'DFTY 'DCTY 'DBTY 'bty)

and mu_expr 'DFTY 'DCTY 'DBTY 'bty = 
 | M_Expr of list annot * (mu_expr_ 'DFTY 'DCTY 'DBTY 'bty)




let embed_pexpr_expr pe = 
  let (M_Pexpr annots _bty _) = pe in
  M_Expr annots (M_Epure pe)


type mu_impl_decl 'DCTY 'DBTY 'bty =
  | M_Def of 'DBTY * mu_pexpr 'DCTY 'DBTY 'bty
  | M_IFun of 'DBTY * list (symbol * 'DBTY) * mu_pexpr 'DCTY 'DBTY 'bty

type mu_impl 'DCTY 'DBTY 'bty = 
  map Implementation.implementation_constant (mu_impl_decl 'DCTY 'DBTY 'bty)

type mu_label_def 'DFTY 'DCTY 'DBTY 'bty =
  | M_Label of 'DFTY * ('DBTY * list (symbol * 'DBTY)) * list annot * mu_expr 'DFTY 'DCTY 'DBTY 'bty
  | M_Return of 'DFTY

type mu_label_defs 'DFTY 'DCTY 'DBTY 'bty =
  map symbol (mu_label_def 'DFTY 'DCTY 'DBTY 'bty)

type mu_fun_map_decl 'DFTY 'DCTY 'DBTY 'bty =
  | M_Fun of 'DBTY * list (symbol * 'DBTY) * mu_pexpr 'DCTY 'DBTY 'bty
  | M_Proc of Loc.t * 'DBTY * list (symbol * 'DBTY) * mu_expr 'DFTY 'DCTY 'DBTY 'bty * mu_label_defs 'DFTY 'DCTY 'DBTY 'bty
  | M_ProcDecl of Loc.t * 'DBTY * list 'DBTY
  | M_BuiltinDecl of Loc.t * 'DBTY * list 'DBTY

type mu_fun_map 'DFTY 'DCTY 'DBTY 'bty = map symbol (mu_fun_map_decl 'DFTY 'DCTY 'DBTY 'bty)

instance forall 'DCTY 'DBTY 'bty. (Located (mu_pexpr 'DCTY 'DBTY 'bty))
  let locOf pe =
    let (M_Pexpr annots _ _) = pe in
    get_loc_ annots
end

instance forall 'DFTY 'DCTY 'DBTY 'bty. (Located (mu_expr 'DFTY 'DCTY 'DBTY 'bty))
  let locOf e =
    let (M_Expr annots _) = e in
    get_loc_ annots
end


type mu_linking_kind = Core.linking_kind

type mu_extern_map = Core.extern_map

type mu_globs 'DFTY 'DCTY 'DBTY 'bty =
  | M_GlobalDef of 'DBTY * mu_expr 'DFTY 'DCTY 'DBTY 'bty
  | M_GlobalDecl of 'DBTY

type mu_globs_map 'DFTY 'DCTY 'DBTY 'bty =
  map symbol (mu_globs 'DFTY 'DCTY 'DBTY 'bty)



type mu_struct_def 'DCTY = list (Symbol.identifier * (Annot.attributes * qualifiers * 'DCTY)) * maybe flexible_array_member
type mu_union_def 'DCTY = list (Symbol.identifier * (Annot.attributes * qualifiers * 'DCTY))

type mu_tag_definition 'DSTRUCT_DEF 'DUNION_DEF =
  | M_StructDef of 'DSTRUCT_DEF
  | M_UnionDef of 'DUNION_DEF

type mu_tag_definitions 'DSTRUCT_DEF 'DUNION_DEF = 
  map Symbol.sym (mu_tag_definition 'DSTRUCT_DEF 'DUNION_DEF)

type mu_funinfo_type 'DCTY = 'DCTY * list (maybe symbol * 'DCTY)

type mu_funinfo 'DFTY = 
  M_funinfo of (Loc.t * Annot.attributes * 'DFTY * bool * bool)

(* a Core file is just a set of named functions *)
type mu_file 'DFTY 'DCTY 'DBTY 'DSTRUCT_DEF 'DUNION_DEF 'bty = <|
  mu_main    : maybe symbol;
  mu_tagDefs : mu_tag_definitions 'DSTRUCT_DEF 'DUNION_DEF;
  mu_stdlib  : mu_fun_map 'DFTY 'DCTY 'DBTY 'bty;
  mu_impl    : mu_impl 'DCTY 'DBTY 'bty;
  mu_globs   : list (symbol * mu_globs 'DFTY 'DCTY 'DBTY 'bty);
  mu_funs    : mu_fun_map 'DFTY 'DCTY 'DBTY 'bty;
  mu_extern  : mu_extern_map;
  mu_funinfo : map symbol (mu_funinfo 'DFTY);
|>



(* let rec instantiate_esave_type_symbol typ_subst e = 
 *   let do_rec e = instantiate_esave_type_symbol typ_subst e in
 *   let (M_Expr annots expr_) = e in
 *   let wrap expr_' = M_Expr annots expr_' in
 *   match expr_ with
 *   | M_Epure _ -> e
 *   | M_Ememop _ -> e
 *   | M_Eaction _ -> e
 *   | M_Ecase asym pats_es ->
 *      wrap (M_Ecase asym (map (fun (pat,e) -> (pat, do_rec e)) pats_es))
 *   | M_Elet sym_or_pattern pe e ->
 *      wrap (M_Elet sym_or_pattern pe (do_rec e))
 *   | M_Eif asym e e' ->
 *      wrap (M_Eif asym (do_rec e) (do_rec e'))
 *   | M_Eskip -> e
 *   | M_Eccall _ _ _ -> e
 *   | M_Eproc _ _ -> e
 *   (\* | M_Eunseq of list (mu_expr 'DBTY 'bty) (\\* unsequenced expressions *\\) *\)
 *   | M_Ewseq pat e e' -> wrap (M_Ewseq pat (do_rec e) (do_rec e'))
 *   | M_Esseq pat e e' -> wrap (M_Esseq pat (do_rec e) (do_rec e'))
 *   (\* | M_Easeq of (symbol * 'DBTY) * (mu_action 'bty) * (mu_paction 'bty) (\\* atomic sequencing *\\) *\)
 *   (\* | M_Eindet of nat * (mu_expr 'DBTY 'bty) (\\* indeterminately sequenced expr *\)
 *   | M_Ebound n e -> wrap (M_Ebound n (do_rec e))
 *   | M_End es -> wrap (M_End (map do_rec es))
 *   | M_Esave typ s args e -> wrap (M_Esave (typ_subst typ) s args (do_rec e))
 *   | M_Erun s asyms -> e
 *   (\* | M_Epar of list (mu_expr 'DBTY 'bty) (\\* cppmem-like thread creation *\\) *\)
 *   (\* | M_Ewait of Mem_common.thread_id (\\* wait for thread termination *\\) *\)
 *   end *)
